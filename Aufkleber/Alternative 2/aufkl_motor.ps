%!PS-Adobe-2.0
%%Creator: dvips(k) 5.996 Copyright 2016 Radical Eye Software
%%Title: aufkl_motor.dvi
%%CreationDate: Mon Oct 17 18:57:52 2016
%%Pages: 1
%%PageOrder: Ascend
%%BoundingBox: 0 0 98 155
%%DocumentFonts: SFRM0800
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips aufkl_motor
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2016.10.17:1857
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 919 2014-05-19 18:42:47Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.24, 2016/04/22
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionary
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/Log { dup 1e-20 lt { pop -1e30 }{ log } ifelse } def % control the log
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/Acos2 { 2 dict begin 
  /x ED /y ED
  y abs 1.0e-20 lt { 1.0e30 } if
  x y div 
  dup dup mul neg 1 add dup 0 lt {		% arc cos needs two values x,y
  pop pop 0 }{ sqrt exch atan} ifelse 
  y 0 lt { 180 add } if
} def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def % Polar to Cartesian
/PtoCab { dup cos 4 -1 roll mul 3 1 roll sin mul } def % Polar to Cartesian (Ellipse) a b phi-> x y 
%/Rand { rand 4294967295 div } def		% a real random number
/Rand { rand 2147483447 div } def		% a real random number between 0 and 1
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%
/startGlobal { true setglobal globaldict begin } bind def
/endGlobal { end false setglobal } bind def
/pssetRGBcolor /setrgbcolor load def
/pssetCMYKcolor /setcmykcolor load def
/pssetGraycolor /setgray load def
%
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  /Scale ED
%  1 exch div round /penroseFactor ED 
%  a 0 dtransform round exch round exch
%  2 copy idtransform 
%  exch Atan rotate 
%  idtransform pop /a ED 
%  .25 .25 itransform pathbbox 
%  /y2 ED 
%  a Div ceiling cvi /x2 ED /y1 ED 
%  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
gsave
  220 150 translate
  Scale dup scale
  systemdict /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
%  pop pop 
} def
%
/PenroseFillA {%  on stack: scaling factor, border color, kite color, dart color
  /Scale ED
  Scale dup scale
  /border_colour ED 
  /kite_colour ED 
  /dart_colour ED
  clip 
  newpath 
  gsave
  100 100 translate
  6 
  Scale 1 lt { 1 Scale dup add div mul cvi } if %%%%   Number of iterations
  10					%%%%   Long side length in millimeters
  /border_width { L 0.06 mul }def		%%%%   Choose the scalefactor for the borders
  /L exch 25.4 div 72 mul def		%%%%   Conversion: mm -> inches -> points
  /f{-1 5 sqrt add 2 div}bind def		%%%%   The reciprocal of the golden ratio
  /l{L f mul}bind def			%%%%   Short side length l = L*f
  /Ll{L l add}bind def			%%%%   Ll =  L + l
  /c{36 cos L mul}bind def		%%%%   c  =  L*cos(36)
  /s{36 sin L mul}bind def		%%%%   s  =  L*sin(36)
  /draw_tile { 0 0 moveto c s lineto 0 lineto gsave closepath gsave fill grestore
	     0 setlinewidth stroke grestore border_colour stroke } bind def
  /half_kite { dup dup 0 gt{ 1 sub gsave f f neg scale -36 rotate half_dart
			   Ll 0 translate 144 rotate kite grestore }
	      		 { kite_colour L draw_tile }ifelse
	     pop } bind def
  /half_dart { dup dup 0 gt{ 1 sub gsave f f scale half_kite
			   -144 rotate Ll neg 0 translate half_dart grestore }
	      		 { dart_colour l draw_tile }ifelse
  	     pop } bind def
  /kite{ gsave half_kite 1 -1 scale half_kite grestore }bind def
  border_width setlinewidth  1 setlinejoin  1 setlinecap
%  450 0 translate  
  dup f exch neg exp dup scale
  5 {kite 72 rotate } repeat stroke 
  grestore
} def
%
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/CalcBezierSpline {%  Christoph Bersch
  10 dict begin
  /getX { Points exch 2 mul get } def
  /getY { Points exch 2 mul 1 add get } def
  /n Points length 1 sub 2 idiv def
  /GetFirstControlPoints {
    /x n array def
    /tmp n array def
    /b 2 def
    x 0 rhs 0 get b div put
    1 1 n 1 sub {
      /i exch def
      tmp i 1 b div dup 4 1 roll put
      i n 1 sub lt { 4 }{ 3.5 } ifelse exch sub /b exch def
      x i rhs i get x i 1 sub get sub b div put
    } for
    1 1 n 1 sub {
      n exch sub
      dup dup x exch 1 sub 2 copy 6 2 roll
      get 3 1 roll tmp exch get
      exch x exch get mul sub
      put	
    } for
    x
  } def
  % 
  n 1 eq {
    0 getX 2 mul 1 getX add 3 div
    0 getY 2 mul 1 getY add 3 div
    exch dup 3 1 roll 2 mul 0 getX sub
    exch dup 3 1 roll 2 mul 0 getY sub
    [ 0 getX 0 getY 7 3 roll 1 getX 1 getY ] /outPoints exch def
  } {
    /outPoints 6 n mul 2 add array def
    0 1 n {
      dup dup 6 mul dup 1 add
      outPoints exch 5 -1 roll getY put
      outPoints exch 3 -1 roll getX put
    } for
    /rhs n array def
    1 1 n 2 sub {
      rhs exch dup dup getX 4 mul exch 1 add getX 2 mul add put
    } for
    rhs 0 0 getX 1 getX 2 mul add put
    rhs n 1 sub dup getX 8 mul n getX add 2 div put
    GetFirstControlPoints
    1 1 n 2 sub {
      rhs exch dup dup getY 4 mul exch 1 add getY 2 mul add put
    } for
    rhs 0 0 getY 1 getY 2 mul add put
    rhs n 1 sub dup getY 8 mul n getY add 2 div put
    GetFirstControlPoints
    0 1 n 1 sub {
      /i exch def
      2 copy
      i get outPoints 6 i mul 3 add 3 -1 roll put
      i get outPoints 6 i mul 2 add 3 -1 roll put
      2 copy
      i n 1 sub lt {
        i 1 add get i 1 add getY 2 mul exch sub outPoints 6 i mul 5 add 3 -1 roll put
        i 1 add get i 1 add getX 2 mul exch sub outPoints 6 i mul 4 add 3 -1 roll put
      }{
        n 1 sub get n getY add 2 div outPoints 6 n 1 sub mul 5 add 3 -1 roll put
        n 1 sub get n getX add 2 div outPoints 6 n 1 sub mul 4 add 3 -1 roll put
      } ifelse
    } for
    pop pop
  } ifelse
  outPoints
  end
} def
/Spline {
  /showpoints ED
  counttomark 2 div dup cvi /n ED
  n eq not { exch pop } if
  ] /Points ED
  n 1 gt {
    CalcBezierSpline
    mark exch aload pop
    ArrowA
    n 2 sub {
      6 2 roll 4 2 roll curveto
    } repeat
    6 2 roll 4 2 roll ArrowB curveto
  } if
} def
/OpenSymbolSpline {
  Spline
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
%
/isbool { type (booleantype) cvn eq } def
%
/Ellipse { 
  dup isbool { /MoveToStart ED }{ /MoveToStart false def }ifelse  % false or true
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 
  MoveToStart { 0 0 moveto 1 0 rmoveto } if  % move to the start position
  0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput {
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  5 dict begin
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 919 2014-05-19 18:42:47Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.07, 2014/08/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
%currentdict /Pi known not { /Pi 3.14159265359 def } if
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
/I2P { AlgParser cvx exec } def  % Infix to Postfix
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length 3.1415926 /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_floor {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 842 2013-10-26 10:25:41Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.04, 2013/10/26
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
/ps@ReverseOrderOfPoints { % on stack [P1 P2 P3 ...Pn]=>[Pn,Pn-1,...,P2,P1]
  5 dict begin       % all local
  aload length /n ED % number of coors
  n 2 div cvi /m ED  % number of Points
  /n1 n def
  m { n1 2 roll /n1 n1 2 sub def } repeat
  n array astore
  end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
/rightTrim { % on stack the string and the character number to be stripped  
  /charNo exch def
  dup
  length 1 sub -1 0 { 
    /i exch def dup i get charNo ne { exit } if 
  } for
  0 i 1 add getinterval
  dup length string copy
} bind def  % leaves the stripped string on the stack

/psStringwidth /stringwidth load def
/psShow /show load def

%/stringwidth{ 32 rightTrim psStringwidth } bind def

%/show { 32 rightTrim psShow } bind def
%-----------------------------------------------------------------------------%

/pgffunctions {
    /pgfsc{}bind def% stroke color is empty by default
    /pgffc{}bind def% fill color is empty by default
    /pgfstr{stroke}bind def%
    /pgffill{fill}bind def%
    /pgfeofill{eofill}bind def%
    /pgfe{a dup 0 rlineto exch 0 exch rlineto neg 0 rlineto closepath}bind def% rectangle
    /pgfw{setlinewidth}bind def% setlinewidth
    /pgfs{save pgfpd 72 Resolution div 72 VResolution div neg scale 
      magscale{1 DVImag div dup scale}if 
      pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind def% save
    /pgfr{pgfsd restore}bind def %restore
    userdict begin%
    /pgfo{pgfsd /pgfx currentpoint /pgfy exch def def @beginspecial}bind def %open
    /pgfc{newpath @endspecial pgfpd}bind def %close
    /pgfsd{globaldict /pgfdelta /delta where {pop delta} {0} ifelse put}bind def% save delta
    /pgfpd{/delta globaldict /pgfdelta get def}bind def % put delta
    /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse % install .setopacityalpha 
    /.pgfsetfillopacityalpha{/pgffoa exch def
      /pgffill{gsave pgffoa .setopacityalpha fill 1 .setopacityalpha newpath fill grestore newpath}bind def
      /pgfeofill{gsave pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore newpath}bind def}bind def
    /.pgfsetstrokeopacityalpha{/pgfsoa exch def /pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind def}bind def
    /pgffoa 1 def
    /pgfsoa 1 def
    end
} def
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 801 2013-07-09 18:10:41Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: cm-super-t1.enc 0 0
% This file is generated from `T1uni.map' and `glyphlist.txt', `gl-other.txt'
%
% LIGKERN hyphen hyphen =: endash ; endash hyphen =: emdash ;
% LIGKERN quoteleft quoteleft =: quotedblleft ;
% LIGKERN quoteright quoteright =: quotedblright ;
% LIGKERN comma comma =: quotedblbase ; less less =: guillemotleft ;
% LIGKERN greater greater =: guillemotright ;
% LIGKERN f f =: ff ; f i =: fi ; f l =: fl ; ff i =: ffi ; ff l =: ffl ;
%
% LIGKERN space {} * ; * {} space ; zero {} * ; * {} zero ;
% LIGKERN one {} * ; * {} one ; two {} * ; * {} two ;
% LIGKERN three {} * ; * {} three ; four {} * ; * {} four ;
% LIGKERN five {} * ; * {} five ; six {} * ; * {} six ;
% LIGKERN seven {} * ; * {} seven ; eight {} * ; * {} eight ;
% LIGKERN nine {} * ; * {} nine ;
%
/T1Encoding [
% 0x00
/grave
/acute
/circumflex
/tilde
/dieresis
/hungarumlaut
/ring
/caron
/breve
/macron
/dotaccent
/cedilla
/ogonek
/quotesinglbase
/guilsinglleft
/guilsinglright
% 0x10
/quotedblleft
/quotedblright
/quotedblbase
/guillemotleft
/guillemotright
/endash
/emdash
/afii61664
/perthousandzero % PERTHOUSAND ZERO
/dotlessi
/dotlessj
/ff
/fi
/fl
/ffi
/ffl
% 0x20
/uni2423
/exclam
/quotedbl
/numbersign
/dollar
/percent
/ampersand
/quoteright
/parenleft
/parenright
/asterisk
/plus
/comma
/hyphen
/period
/slash
% 0x30
/zero
/one
/two
/three
/four
/five
/six
/seven
/eight
/nine
/colon
/semicolon
/less
/equal
/greater
/question
% 0x40
/at
/A
/B
/C
/D
/E
/F
/G
/H
/I
/J
/K
/L
/M
/N
/O
% 0x50
/P
/Q
/R
/S
/T
/U
/V
/W
/X
/Y
/Z
/bracketleft
/backslash
/bracketright
/asciicircum
/underscore
% 0x60
/quoteleft
/a
/b
/c
/d
/e
/f
/g
/h
/i
/j
/k
/l
/m
/n
/o
% 0x70
/p
/q
/r
/s
/t
/u
/v
/w
/x
/y
/z
/braceleft
/bar
/braceright
/asciitilde
/hyphen.alt % HANGING HYPHEN
% 0x80
/Abreve
/Aogonek
/Cacute
/Ccaron
/Dcaron
/Ecaron
/Eogonek
/Gbreve
/Lacute
/Lcaron
/Lslash
/Nacute
/Ncaron
/Eng
/Ohungarumlaut
/Racute
% 0x90
/Rcaron
/Sacute
/Scaron
/Scedilla
/Tcaron
/Tcommaaccent
/Uhungarumlaut
/Uring
/Ydieresis
/Zacute
/Zcaron
/Zdotaccent
/IJ
/Idotaccent
/dcroat
/section
% 0xA0
/abreve
/aogonek
/cacute
/ccaron
/dcaron
/ecaron
/eogonek
/gbreve
/lacute
/lcaron
/lslash
/nacute
/ncaron
/eng
/ohungarumlaut
/racute
% 0xB0
/rcaron
/sacute
/scaron
/scedilla
/tcaron
/tcommaaccent
/uhungarumlaut
/uring
/ydieresis
/zacute
/zcaron
/zdotaccent
/ij
/exclamdown
/questiondown
/sterling
% 0xC0
/Agrave
/Aacute
/Acircumflex
/Atilde
/Adieresis
/Aring
/AE
/Ccedilla
/Egrave
/Eacute
/Ecircumflex
/Edieresis
/Igrave
/Iacute
/Icircumflex
/Idieresis
% 0xD0
/Eth
/Ntilde
/Ograve
/Oacute
/Ocircumflex
/Otilde
/Odieresis
/OE
/Oslash
/Ugrave
/Uacute
/Ucircumflex
/Udieresis
/Yacute
/Thorn
/SS % Germandbls
% 0xE0
/agrave
/aacute
/acircumflex
/atilde
/adieresis
/aring
/ae
/ccedilla
/egrave
/eacute
/ecircumflex
/edieresis
/igrave
/iacute
/icircumflex
/idieresis
% 0xF0
/eth
/ntilde
/ograve
/oacute
/ocircumflex
/otilde
/odieresis
/oe
/oslash
/ugrave
/uacute
/ucircumflex
/udieresis
/yacute
/thorn
/germandbls % or /germandbls.alt
] def

%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/@beginspecial{SDict begin/SpecialSave save N gsave
normalscale currentpoint TR @SpecialDefaults count/ocount X/dcount
countdictstack N}N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto
0 vs rlineto hs neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale
ang rotate rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}
ifelse scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale
llx neg lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly
lineto urx ury lineto llx ury lineto closepath clip}if/showpage{}N
/erasepage{}N/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{
count ocount sub{pop}repeat countdictstack dcount sub{end}repeat
grestore SpecialSave restore end}N/@defspecial{SDict begin}N
/@fedspecial{end}B/li{lineto}B/rl{rlineto}B/rc{rcurveto}B/np{/SaveX
currentpoint/SaveY X N 1 setlinecap newpath}N/st{stroke SaveX SaveY
moveto}N/fil{fill SaveX SaveY moveto}N/ellipse{/endangle X/startangle X
/yrad X/xrad X/savematrix matrix currentmatrix N TR xrad yrad scale 0 0
1 startangle endangle arc savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
%%BeginFont: SFRM0800
%!FontType1-1.0: SFRM0800 0.3
%%CreationDate: Wed Sep 12 2001
% Copyright (c) 2001 Vladimir Volovich <vvv@vsu.ru>.
% See the file COPYING (GNU General Public License) for license conditions.
% Converted from METAFONT EC/TC and LH fonts:
% ecrm0800, tcrm0800, larm0800, lbrm0800, lcrm0800, rxrm0800.
11 dict begin
/FontInfo 6 dict dup begin
/version (0.3) def
/FullName (Computer Modern Roman) def
/FamilyName (Computer Modern) def
/ItalicAngle 0 def
/isFixedPitch false def
/Weight (Medium) def
end readonly def
/FontName /SFRM0800 def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] def
/FontBBox{-203 -320 1554 938}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA052BD0CE60552BD63101D7CDBEEF5B11
69C468645FE4ED1AF2541AA0770C1DCF81623DE0ECDF49F2B522618F650CE6CB
CC8C21885DD61AF8A523AA677EAEDDFA51A1F9B1885EEE0456196D634E04EF89
F17499DAD982502ACC349B9EEAAE4A71A73D1147318C60A8BAC10510DE90D8D3
F46E47295D27129A5AFE0C65E22BAD10D06885A2EE623FF8E1D90287A083E00C
EF25195F68A2A98170E48759F33528B839DFD4B92DF0482493852D12053A7904
BF6E144B948894BA0E437691D4618A0FFB62E3630B93DD190EBC8F306BB78955
34955AD847F95B1923B90644A4707B718BCB527F8D5F617EC559C70A91900E72
9A9D881D02E289B0B0725B43F5FE653ECE8C5F062BD2C10F4B9B0ED3938F84D7
FD5D3725C3F438E46A270FD43270689A5F30B1FD8CD61E7CB544F07FE57D719E
17CB8A7A146AC514A35380CC6D93840A2DCFBE40307F2FFD8AFC0E54D066DAFC
025AD2A93593551D363563A2208329634F6BD80400775EA44ED4F59B0F767946
25D1A692A6C9197B50C369ADC30DACF14BB7FBF9EFA9AC4894FE3E0A6B3245B0
7E7353569A285310D32E52C36FE2A2827319227E0B024A615243399486706FF6
9E76827C1ED6ED10CA2C9E369D5A507991070CB699F666AFA47FB9EE3D968112
38D5F4624378D9B34F8B00E280EA3F61E4CB33EDCC35F0433A4EF6D267C08A0C
5D5A95A531D8A0E1DB1394DA5F72EF2ACE4CFDF20871C679418FB1B481CC5EAC
C1733601DE79FE5D9B793234D4DE58546A5068CACB9EB1D82644358DAE105ED7
BAAF89A47AF526E481D3E105141FC7EB61A5E5602412613D25A39EFCD8AC6ECB
1ED92210690BA38F6A1E1D49AF1B6C8D7904633F0CA55E1E951E9BEED4339DE1
5C97307776C6238E3C3749F55276DE11C29565BC5914A12E414818AB259FFDF6
EFDA0F520257D55915532D048497C4A45E813004BA89D16F34E847E14FB85C6D
F655651F7F8F93BB3B8BF3D37D4BEE651C58CE6F89A0E4A039F7672039ACC235
797D06645170342BF3F67146194DD1FA79F2A5879C5E9546B2A3698E3F716527
D480F7B35F92ED9E284CCD6B344555843F4697DA8ED586320141BA36D5C3AC01
D34F8800522E4154E66120234EA715800AD9A9B7AF56296934D0377F7FE0FB41
B994AD131029C4A51B6AC1BAA22C0A5564547A9F05D5BA7EBC2C184831B46490
CE0F1C4EF1ED2387628BB7B0527FEB50212522C8D4156C9152A59D68D0704585
B969251F67BEBCD432452696E15D7C3D781959DAB1F20D320C6496DDFF0E73C1
6B94578EC769DA4EDD9F342275BF50B965513FE075521A8C020F9A3AA806F512
E976E351613F23E810E4DA5FD336C660B2D06585EF6D1A99402DD795317EA4E7
786D750C09528DDF1BC70C66D1F3B544E7C1D64DCEAB7476A2E394518D3B7085
CDB8B755057EE574A158761FA7F6FF3081DC39F81477A8BCF7C9E71F26E4FF8E
D3F35B5FA5BD6D0F4E85EEC43ACB5569CEDF46D479F1361AF8C72F0116C1AE65
B5769470BB43DE8DD9B41B05DE74ADEE20EF53751328E391BA0A83699AFDAB98
39261F94F3172250DCE97CFFDDC72835A46F4CA8FA0A2A98C9BF237704BEE908
4547F0AB1BBCA5345ACF706FF4096445A087B13F6BA87C92E8EE22AA8B1D324C
FB407059F595DE66EE6407CA92FF940D5C2EA0707CEABD8F2BAF1C80D8BFDAFF
758C9E8706E8C944274A1D9CE79A9A319C6559B46661FA8BF8A6B340679F9423
11B1018F6210E7BF228137652ED54DE66F7844DD74DFBBA3C4339634DAB87319
E9E3072D79559B33C05412CBACF296E30EBC12722EACF48594016B4B9C30CC1B
8E826C6FF5F775F9A14B2E70FBC38D6D3AA58780190F135901882D75D1C1FB40
D06B955B1E11897D5CD320995D0873F607C5FC4459744016FE0B3D2BA9BCFC6E
40DC39A24FD0F31FE8A94F1A515BD7A9B8923061CD16B6AB1774BE2256A995E3
C2F0AB3B2B7D233FC29C3822DE5DD1D98664245056238422268ADA4EA95315C7
14D1CD3A80C0AB9562133BA2AF5597592B3816CD777C55A2E36F61EF76AC6D76
BA75C0EE14BA0A9142B05B2B85301E6EEF72E5949236930BC41432A9CFF554B8
4C9A4373F20D95B61A9E7E90665633A83E7F9C5E2F62303F3533CFBCEC9A2D13
D426B95F0EF5022436D6A5171E4D5FE3010E26CF97B8EB2D0EDDCF65254BBD87
B538A8BDC93D4009C2ED9FD00797AEE5169BAE41BF05899772E4D7CE48276DE9
EB064FA545841C4E2802C3E67B20B98842A0DE224CB112894CD29588B5AB84F7
4FE3EDF6E48B9AB4C904556AD2695644AC890E05A8E6A0F94C6F1D948D8BB487
C825E7D9AC7D0D86B75F5E18C430D828A7C16A81002AE7A643482B4529D90457
FABEDD3CF1971308515E9151219C86CB4597F46AAE7CE33D9440333E343C1044
50F9A59E02997BE90DA8E48524A513FA04C776B1AFBF0CEFA511705575254CD6
BE941653699D768F4B57A8B7E7FC9F34D3D86AB9ED7C85204A101370ABD3E4AF
6708A85CB82ED7446D93AAABBB713529E061935084759EDDA78BBFD92AA5A14E
7CB52FC8FAA962353258BB0ED9B4CB16592EA6E1670ABBB567A4E0190BC27A79
57EE58BB069706D9CD6C558E32883C232279591314013EAF4F40ADEB9BC084FE
7D1A57FFEAEF857F8AA17C9DB6991F69B23DCE13ABD5A536D9B86CBA83317632
3D1EA2402B20E1C644609DC9FD5C01CE36F2E2C2587B4F6056E6FC48F76C7F1B
0ACF9023E2C046AA65788D33CB2BFDDAEFA453CDCB028B101ADD926E05A51787
E4277BE65DAEDB3F4B86CFEFB98F81490361B1746E33F5C90502CA9C94DF682F
AE64D2EFAC8D2CCE2F9B628074FBFDC94FE4F5722743E024285C303F1BD91512
F7C4CEC0813D3F76F0AC25F74E3C69669E6A2CC10A9928179D61E59EA1468176
408ECE0505CD2516A57CB4219EC83690DB3C736FACA7F6B4AC7ACE16CB7739F4
4677F9F0750DC17FD83201C75DFB142D13285E87CC401FB37A6A7418ABDA3783
24D093D273C16FD48EDA05BAD3227B40E968467CB2180ABA1F8D72028B38DD46
3669C7A6A60DA0FEFDA31FDBE395B66C629D8843ECD42077E8F843EF3D67703D
38F1C1190AF61B7C65890DDD9D7C0860B89D4C10114DEA1302600E104D8398E1
0A7FF982B67F7B7C305BEB9C2EAA7703C15B1D1DE945308603D78C4FA3D5D2A9
C903684C07F2022B7CCD5CA04627DC50A40E90BF3094539F00C8B47FA1FD2CCA
DD9318968B958BA370B85906F6C77FB558D0AAF789A8805F8D7366A4E13AA495
1AA30A10324073F2400FAA323F65832BEF101B97738A68C586795965DDC9E630
A474FC6296EDEE1C48D6452C32E717E684C7D589F29C9B5E0BB1C42C9A95D93F
28D778A262844FB112A5C09FE173C3E66917429FA80959392DB9CD0398C35E56
F2C42FA6639E63549C6ACF9744C2315DFEE44BB270C4073D8747F3BED6E631D3
00A09B49DC61286315C1F5085DB94B57A71E9D090EA39D73D43E91115F3BE196
C9252A0445F4E517CE32D19CB928BB457D5BFDA268E527AE5009940D60B68C7C
72E6561998FB670C1411F15CA5FA0193B82DA3BB1DA1E7ADE0E565DF01D7B498
668DF6990A4E2CAD516FA13BC8F6DEBC7B67B93509E018FE79D6DA1CFE4D5AC1
FDFD387E42839F5BF88B037C9068030CD7EA9F222E44FE2E6A8B1E51A7B32DA4
2D6CA989094194A4D791F756EABA2385432DA0B395523EFEB6E118FD1D464528
9B67B0297BA9FB3CA353336FAF9A4DF44261F97988E5FA97105607AB6EA76235
AC1601E26F8F20910AB094CA9DC3606B93D70A3933234DE31EF63CF58A03F07F
BF5EDCB79787639A1BCD39A8B77A80127C68342B9CA175593C5FC0ACE9FA87B5
997486B5A99CD3FCE9BD87A1114D5C0A630BFD6A534A54D4B007151805E74974
5B4F1FA778D487318F25ACF07A282E73FC996B5D111D5560CAE9C4733EDB2538
301804DFB91962B54853F62115F5B63CCDB8DE2378DDEBB6513846479C3AB4AF
7BCD25FF1756C2EBD239A20C2DFABA00C4A9D139FF222E949E21E1A6093D8CF5
3621656272B2D64975DC69CC97C4F15E9146632DDCC8122FE2D30282A40DB99B
2FC5F3FC381B2FE8997EC131EC9D5E52D969A2B50DAAD0B7A7E7F11898B3E6BB
80FA75CEFA67FF202F2ED74451FDF614A2CED24DA5B2122BBDAC6C9C806CDAEC
4D2C6257D580A033F8F4DA39D7A73C7B544AC695D564B5F148C8933DAF380988
46BCB0852661648D8AE9B0A53398967291D8F4C507DFC5B16D7589D623BC039D
A83B1BBFD3F8DB9C9CB0EA74E2E9D9A705604EFD0DB86ADB87A4CDAF39445075
73EB3C45554F6F0970820505B0BB5F32A07E44DF4DCD65ADF063952E488CD00B
120B07D80245F249EC5175F99CB6978AA0E9ADED4A97E92F225BBC3EC207E868
CF80D10207D2C8B19311384A328603BDC1497FA815CF4FE4FAB54440AE6AE7A1
49177A5BC1FECFC5F9582E3BDDC7C08E9327862E9C661AB681AEAA9A67058400
B0AF3303959A339F11AC22ACE46B483FE445A81E1217296BA621CC1F7945FCC1
11D4A94ADC6377CA469C545315E5B7C88ABB5D2E78A5A203CD62AFE112062435
47DBB0CB656742401BF3764FBA0E66BEFD41F59473C05D77D60B0A3658E39E7F
BB2ED667799B7815CA48217EE015B1B12CA97F43106CD5CCED9E14B908A5D605
3506C39170592F617BCCDE708FC1DA5F5108063281861A44804661F8162C27FE
5EB94E154DD58C6272C9822A819B26D8C6D64C5179A1F26396459BFAD95C13D4
E1A8763425CBAEEB79A3172499407F5DCF2351942B10206BBE5A3197580F66F8
B14C146845BAAFEFBFE4CF36EC39D2B59381AD5D4B51390098DA93060F9CB612
332BFA5DCB99A9757AFB867B901F6DC7B0BFD28142BFD50CA5E2DB14A9C2E42F
E8B1787C46DB5A55BCF67F2B295D688BB670CF732EC95E9148DDC598D67A8707
54F04CCF80AE6D52908D7C4921FE539E4BD33CBB34C3497682808EA27BBB4ECA
6774D2B717CBB05AC4C43E1B9E918E2730C558421C3464DD28CD502881D30E13
7838B8BA1EE7F97C722EBA18B6BAF602E631BD20B064F56C35CA7EF4D761CF20
D1BDD9B918062400F936A215D0FA6F9099E760DB4FD58B0977431EB6A05E1053
98AF8020A4B455D0662A1AC81F3A92E9B949075B392B84CF41132A47B69C0C09
A047D681917454D7C4A1939E8D091D701E90C47E1A084CCC8904BD69374C7767
4F90A9F3F62014A59159D28EEB468CFFF895B7C475C0D7E5E46F213B789F4EF9
16E7B7141C0ACEE4650B11631704A062C1EFD6456C367C70A5384DD5A9AE100C
A63A3D6C518F6D29B4BDB422028061F5D0EC777A0BDDD302BEC9229954C056A1
DDD00034078F19364D0ADFF64E22E62E87D15146ACDD40E930BF7ED6D4E13297
D788550F4AD1A1327279D514F091EF73B4B066BA773F743CCEE8A9DE3EB39D72
E9C776AC7EE47B48D7462DA74326745D538D71CB310BB9D9816EE00B91904AD3
454116CA130F17185635E9AEBEA5472CAA52FEC5E85739E3F64E5A7188083EEF
BB91242CF041FBF55B856954D5DB273F2294784A3E76CE357DDFE4E844A99CEE
9C100E2738EB997D3EC9C30BBAB040C8D257870A18C5A469611D9D4D59261257
E367065285D0BE958FCB242CB73DF15B9675A81ED724A3A96B8A8E037FB136B1
AF98BA472BA799ABFFC6FC7B4DADA7776F15EDF1926090CBDA0B1D9696D2B0B6
21CD5621CC1D691E2D29331D9968FC0D47989BFA4024D6C2D258DE4B038DB988
718ECF1F8A590A132E2CDB9F75B17B2F16E43F5AE8261C0526EE475BF2EE1217
4C7CD69633A507B5474DC327006C357D6EDA1AA0D91780774167495145FDA7C0
E4764477F6328EF645DD583F7E287815E6206F29BFA9DF208073812B037323C7
99ABF268B5FFB595AF1DFA711ADB30AF5F9D5784D0B66AA0C3A368023E1D849C
76D04BCE4849FE094A5F972724E4E37E04CFC879DABD78E652C2F30A8E54F983
1C22A9C6FBAD4A5D20F923534838A27ACCDF54DCCE517C629F3B744B51DF6307
E4E83D61F68D73A3734B8EC9D803D367755DFF75C875C319DE2724FBA0A97D3B
7B799F44EA1A2247E9F3D8F2FBB24CEE0637FFF77D947B7ECCFCE2402E3E6AD4
A89136EC8BC6F38C06C3D6EAD084018DB1E6A0B091019E16FCCB4D4185A3D58A
974363A09E4C16F022A61C834C7CB4B6C439A2E90D07DE351F0EE256CA0F1FF9
956FFE7111F2909C9A8D14697EFF285FD6B8830766027772285C7CE0FAC02DBD
AB88E34AB38324120ABCB022EFC139A013037903C98440DE5F740D62147F7532
DBC90698A22D9E9AD13001F857843F338F5469806CE5C55FBC81DF83C36C5712
64B72348E43DDF50DB540EE7AFD26D4829E03C39AB702BA6E6908560B6787D11
E8BE6B75267A14F8D23CA5874C99F05180852364C58A3C78877F7EDAEB65D5F7
21E2AF047D326D8E9CE647DF4C4C6CE0F4B0DBA3DC7A94213A35415EE8DE6DCE
40884D6426E11F97CF65E90769F00B60AC1E0C0DC1EA7A3714968F2D3E002F30
135A03DC22FBE08F2ABDEF3EE00F2F52D81A86913ADCE5EF6336A1F504604803
DB623C98F7339A9FD26ECC6F8D27D1B62EF4BCFB0B616408DE2A337A8EEA0937
1AFE39987766E3DD926273A74B8972E3E0230261809E2D84A967AB1CD028D471
6C060CF82F494A32C0CAED9235499B3200D6A7E161BDDA5F652B57DA1B52BB54
03C48362EAD0D4D06D60DA5E0CACA1D9959CC050EB936FA92CFB8D553152087F
21DE5E2DDEBDAD2B8F54C5E4824825B58EA4C31879C9B8D8308F037F64757453
3DFFC5E4EDDD6FB7648FA5E8BDA6B32745E850BA7276095874395B824051900A
3EDA64A56EE1572764BEAEE557B5534C3F57C7CEF14802503E67FE3EF21A8962
CC70935C46D4313FC113C1E46ADE60BFCFDDB41F4522435F496C129EC1886AC1
485D64CD6B037252845CE7BDA706F122CD157327FC451018E183F932F7CF11D1
C27E019A58B3837F47AA549D061FBF70D06E9D36A82FD17C38D07C1BF9536A25
EE9A60B370DFB93E6CDA28B0A05AC886A7F399F4767FD1FDEBA5C5ED6F419FD9
7DE21812319E894B54BFDA33CFB64ADBC7489B47263A213680FA30EB481D5C68
580DF67600ADF3783CF01A487CE8D2F23B26AB4E37435BE59C2A1D11BDB6A24A
643058CEB79E21CF3DEA0218424898B25774B911556F0220B5B8FA36670B1745
2B64C054592F4514CF98E3E29C51B85F11C666F6BDFD75AB0D39324BC14C95C4
85620A470C7ED55E9C7088A62618F22160C50043B2DF8293E10BB6746815D55F
0490CC2698B66CBBE74C669A5DF48C0AE5BA1BCF5176098372A1C5344AF36A77
D5EEDE8D2949A7B0415D03C4A8B5653C985EDFFA78298E0C51DA9007033BB90B
D6E7E017A42A6E500522379609D3824A76A540F89B5C7F3458DDA2FDA0A2B393
0AAF03E7142C6AA82FBEED3B27B2E237DBCFC504C34C369BA3D453C73D922475
A7A0F0E934A6BD6E4674A9AE154EA359F717BC5972BDE2D2BB4E21AA5A27891A
505BA717875648C0FBC114419C8F9D7E27DC026C52BD8B96F46B82A1C855FA40
5226F4590AA858588A1F79CC9DA24EEDB8C7D54B1BC1B9AE91F963E1D24F9855
89CEE5D71AB4AAA78CE4D73D8509D3FF3D107988159243942BCBA43485CA97B6
B40F12A0AC87C20C855FF79C21DE7BF692895D4739B776A6D42D96912B220C4B
EEFA8FDECA6A0403E5D98B791F17CD07C713A3CCE62D85B7B49EEEAF9E975788
9B243AC3804EE241C7B861325A9758F70935D55B1F77C8AA9B546FCD5837A7DD
6619E1CE79E47B29535AF7EBC195AB879700F41F3591168B4F9B2D798976DA53
91E5CA83375DBC655C60C520934CB68433FE348ADE89B1A0960CD0DC9D2FFFA8
28A43AE0EB5B07B48DE067F292D7DE67DA4946CF8FEB75D1F1662445F097E760
2C9656760F2DA467C6325B8C95984D512D1EDFFA0A7B7FC7036812216BD5B0F8
BB0F3F6185707423E194DB60B9A04A3D97A473606B23CEE5D63258DF1865E6B0
42751ADA64649D14C608BCB0B4FFB4CF7056F712434B39403226D0E166663353
A1DABEC3D17A276C406CFFC6CEC411E6C73E3DFBBF7E3C9F9A46B04078D23572
F83B2966D69A43F4074B66BC3EB6D74559E2CDFCCBADDA42FC6DA5C5981A80A2
7F62F61FD87D987CB04C1FD21624B745E2C9D0025EAB79CCAA60157052293371
4B300421612964B30A624CF9888ECEC6D3335DBBC359E34822367D2D0B172EF3
98AE19A7D029E70F1D17FCFE74332B80B650CC520C7FF8AE88D8AF9C26BF42EF
50730A103B89A152596DD03EC48242C8C7E39E39E2B6A304ADA49CAFD61DEB97
A98F7B536FFAADBC26FB3B01762043A8DA59AC7218D3DD62CA56A95F558EB0BD
92B6A403C8A7A52B6F61BB07C99A752D3FC0802F4DABBFB9BDCAA486B13F1E17
BB454E692F891EDB27A135990AA936BAED123A2BC3926D03E4312FB7EFB1E318
1CE8AA1CBAD9DD0DE22C313CE16B372ED2FE4D0EEE771A6CFBA90E7571FCC24D
616F0975B16B7C97BFAF9CB9E5ED2606CFE0333B4EFB07B2D56D49AAEBF1241B
97EDFB7A553605C45356F4BA3F247F1E159EEB1408FD1E8FD4F7539A64F8C61C
3368DCDC18A9E14590A249E8CB57E24E49F94BB7189CCE3D47F08FE9EDC18889
212E0CE535F58F5AE00F69D850AA32F6AE678A95B578AC45A2343483ADE27406
53E4C7AA6F48FBF0F90853ACE5038887B345CA00FCC15F0C28AC5A885463B7FB
C374EFE6664848B7645A17A41124595F10900F568CB5A871C290AD24A80BBF26
C3178731825B386131CADF19889B0FE75B3D8896972FC960868E5457441B7FDF
A4046DBBBF8A25AF50162E52B33B4990833C226E67B05F8FDC46F8C48F4DDA1A
1A2774E6837A859D386F4E1114344F77AA7948D6E51026123411E452D336C70F
5FEF0809580745377E8FB1AC87D58BF341F95EC2DBD14BFF27D9F1221B3A9BCD
52FD18F45D29A6B34DCFBDA57DCEA9747733BD3C0DF71184DFFFA7139DB7FBB6
95A7B8E50DE05D767DB0D97F2190EF19AEA0AA826D1C3FAFF112EC2654ACB74B
FAF8F7BCE3FACC38DD8EF92430B9AA1E0E12B521006DB6861E9B8ED51EAF8761
9E8316E259A5320F9214878C181A4195AFCC275FDC6F28894384C48FDD4D1331
1415FEFC9FD4BF8ACFF0E6AF4D8D22068DA9679B53D5C79BAC678AC5C650C13A
327D3880DEC5B6F85E28F5ADEFCF3DE605BCDCD75106F6C77FB558D0AAF789A8
805F8D718C36A07C9DC5DF7A40EA5394485C96847BB345AC7C3BBCF30D931B38
24F2805232AEE41C79F4519224018E884060FF89BA2A9CBA08CD3FF4396E823E
40A4D153C58F0D60B567CBA3810296022ABF592D0E51D69C72D6557B6850A4D4
FAF353D77A494737C74AB3B3B5DCBBD3211FF07D69E21FB4794956FAA69978E0
0BEEABF209F12F5898217F5F2E222BD14323C751080105AB62872DAFA578B489
9BA16EFBF338DF50B54CE2DC59D27A982ACB149F388742C36BFEF08A6FCBE291
91F47662E2FF2F77417386EDFFDAB7E4DEE1E2D2DF92F1768E499699BBAA32DC
A3222FE1D0E9B6F306626E6F71916BC84678A39885C23B30F6BBC6A4DA134FDE
8B5413E788F072F6743A4A26260C362AF7068A8EC3EC9596D002CFB79FA2D07E
8CE14C9FF61BE82A8BE6BA3524FF215824F68F2914E57F259EC203D44D54FAB0
F5A4EBCA4769E37AA26661022E895E3B5148C71E27774627F5DF21B3AB6CD388
5F0012382AA3BBE0CD0E995F14EEF356669E1A56B30B7DFF743CE2EF71B72E2C
19EE8CFF19C60B61F1B41231A55AC2275FBFF50CDD3529059487E75D01F7AE7D
BB42219D5F588ACDA125975270FE99A31D57A872F77CFA006F358DC65C1D8762
621D7887E6D24D8553E18D5C5D184DBFFDB40A1A3F5D89C78FCF7ABF96D67099
47364BA81AAEF295C6AB7DD45EB4EDF6B3B9F8CA7569008D6BF78DF6DA1349EC
C4AE8566E0B575E02B02E5960AF9069ED5C3D22358F8C748DD429C3FC85114F9
806D2710B89FAC3A55BAFE149D7E22C10FB99F32BF469BA5316C4EC71667C746
1E08A9B3D7A2DB0460703EABE2F4537605A534DDDB4A6F9E61E7D057944694E7
CB6098B0BD07C1ABBD84666BF05D01DFBB0793D327C91A2226566CBD7EDA45FE
0335B6EF780BD59AF90472674307CE573648AE81EA4128D244818D2CB4BD5199
146A70324E3CFF770C9A08174F26173D4A52477F7907480874F1BC354B5166B6
C7DC555EC34CE8862FD9ECA512FBA39694FDB0535D5611E1A9DAEB0115E4AF02
473252181342F3A692E0BB3FCA5940BA33B1EF589F0BEF87390010A4EE2ED540
CC71DF9A162FD4A49C1F783A6172A1F73B7C01919FA5578FBCB494B1A2612174
4435A46D519CB9413869EE99A36ABC40CE5118E085F18956F6ED590A03EEFCB7
C512232E0CBA0148987D87357EB83569C4C0D45AE4EAB953127A5001ABF69712
D3F5099993B56B85D57BD390505C2E3429CF3BB1B746FF762F8892AFE91C9C2C
25409D303F33072ADE4EBEEA0E9538A6DAF6921C5F3881436FF246566518EC7B
2471AB2FB0302B99AEAB35B2891C5F6FAF1BFE236653CDE0DAC8BAE048755F63
44D9A9FF3BB3987F7475D676A90215BDA0F24AF0580B2621E7DFBD1F17FAD4AC
EFF4BE176838281E5CABF579FC9116A397E0C835F4EE5418DE2618D69C466498
EFB867231776925E69DF886F18E7DA65773CA2F534BB79BE229103559EC5765A
12B8BEF3C1819320B766793F249827D7B0C790C51188F05E3CAE99AE48F8EDE8
ABC0A239D3AD4E8F827279E58F4996EAB263FAF920D7368C498E5A68F3BC6BF9
40B24672F73D20F200767A18D55DF72A18183A7BC46FDF32162DF7325A9498EA
3B622322C457EC637AEE663CB12B41D8CC90637FAAA554106D27740E09452410
840591D8FF50620AB8D6BBCDFFB281AB0AB46D321DEB7AB0AF62CA942E2DF6FF
5B2551BF8EF7E16BEBED01CAC3F68346680C647884D5DAE9B6BE0BBBB6E470C8
D54A376C39852A32EFAAEE178CD2EF989FA01AF880B3F933376F249BCAAC5D6F
C1A0C295D1510ADD011D365BE2C51E70669BD253224A97DDF30859F148EEA9BF
9B963BBAAB24862F05BA793DB31D5E979F35A3675EC193EAC0DEEA16F65CC458
2CC3219C99D6452B78BC5DEDB824B647B4E462D23E3B3CBE63281367100E6630
7DA379E08DC87FBF18AC181025AF9377005A6B6FCFB8177AFFAD85673116AB29
F05E300B27F326155A00E528090977B35B142C0FFB9E1B5790E4FCE1C20577A5
3ACBB32CEEF28A858811DCBDB44D673D7DC1F9A0446C51F462BFC7807A85BA09
D427BC7A24441BAEA7F5172613C33894C686ACCEC50B2B4E4BCCF9E3B6FF6BB9
C304F5FDCA83A8F7B17599C120A7E06BA4E8450EB4DDD09A15FA653AF2789B1C
29872A8978E6ABAAF9BD6FE18081607D9879DFC44E97DF76A4A6CC320AA4307A
C43F18F6605C07CE8CB61FE5032432E7B3AF4C5522E98154DEA47F44030BA4F0
E1369FFF13067C3FAA93DBCD98E00C448F26362153CC39B53E6F9E5DE2D1F66C
28E1A263D1CB964682687D561D1A2C02385E5E72822F357108B85B438D869CE8
C7F8B077C2DCA103B488B284E37710A9A1AB429277B77E1B69ACA8CF9ADEC1B7
9C8CB867554FC41F0398207A40109543A0E33F06DFB8454F8D0042E0B8FDAE15
81D67FE97C4D9349C68023B412CEF21E6D1D548CA1024917618247A0C184C23C
144B8E106C733EFF49721734DA53F35C5874A9204432243E66A9837BB890FB5F
E60F0B23FBF19DBB3F8D37C19E1034D5F85FC0E21D088545549C89D8733DC9ED
7E6E85CF93CF3937BE25DE46DA396791B5212FAD24715881787ED6F633DD7BC5
B12E1B4AE786097A51304E43F58B741F645E9AD0048D244DE20202BF6071C662
36E534123BF9DF9D5A0C998F2B778A24DD727260B6135CCC946DEFDC1238A94C
73FC58A396261DC2AB3E640EFDD3B35D8BD6C09F29CDB2C15E11B3C984863DFC
3B57802E694B71B5EBCB55ABA4D28616307184EC54E446A3AC14BFF868CA9FB2
1718B45F1D7F03B112EE4C8FA0FF9BB410FD8E8ADF0D346F84320A3CB4C82103
F3792FBB1BECDCB23458C2D90022351192E2B3A5E4218B0B89C65A9D88365CC7
D531258FC77EA9A5A66E5C53FC167EA41266FAA3815C1C88DE2BB999F2E89944
9C01500B01C7229F68E7C55F697AE110C1F8FB9F65ACD4553449CEA8DB230875
2A2D6F8FCB4C69B80B9C6D1A29705AC4150E681D57F7F1DC2F3F8FB20B3809BD
A31B395C21C8EEE4462F49CFE015E1FB85E9C0488748E5509F7D6399DF33A8E1
101310206A1FFFD6538118CE9627DD87BC3DE74A656B5D5C595BD10C610CEC80
EC8D5987FFE19748FD47A70A2E1317354FB80A84B36F7339AE7D7AA45F96AD8E
564418990D646C88671CFCC47F6BE71B86D35F23912234DA3ED916AC09A9DC0E
3A328E1DCA16082699B90A0E2567D6858FDAEE6274E6BE85B4996DA4EE0ACE05
F11543F8133C32AA1444A5B0E54F0F332D220A480C10800D4C8A2199E9FADE36
A8553712A3A549E68CACDEFCAF9C96C496F4C3C84359790EEC08E7B08F182A81
F86C99F89DE681C6A095C4263703BD6CFE5ADC962A659486658FF3386732F01C
86F3D649811B8522B71513DE5D75116BBDA11A21A1225323B52F9C586FD4F080
00C6F5785A07D381DA3B4336A32E52DD152E0A10F6D8A430396F44233AE7AE58
282175C0866F966A5D07CC1DF0CA666C704C0F8A68CCEF7943EA125B11AC8424
26054F8A3F6FFF34C4F6751E576FFC2031F5DEE46462D60AA96E004B8E5B3414
606385395FD76257FE318373679FE05B9E8434352707B1BA6A2BD13ABFF172C4
281B98F0FA313458E50D03C59302F84EE298123F362B36F704E817D6855F0DE2
8DE22D74B9C90D5B9F542D81147E0458A8B7506B037B4D981B6C1C6DA4271D72
111B592701C030CDCF2110282FB5BD06B0424E74997091524E8A62509515B1FC
15340FB87CF551E3DB68463C2C734389027F9D8AFA59B5B96B911CD7BAFF119E
F9DD879A2CB2951CA96E9EC79B8447DA380B03983954E132FB78F6843DA0B259
4EE9642FDB5E4C14E287157394056CCFE6981CB8B0B5A95607684530F2500144
4418493C3E06B3A98C966323C4F2D0DF15C1AE3946453FFD6770A68F67D0958F
7B6763D281D68BDFEA3336AE4857093BEED8C005289F6CAEF4CFBD26B95ABA4E
4EF60D85D6EB6A1411D70BB242B1553FA2642DFCDE99A053213ED71F29ACB8EE
D0C80E4D42118BAE4628F7B51B7929F14FA650B1A6675D63D6D9B782397D4F5A
0C9760959EF8D3F7592821C7797FA23F90EE97045B5F576ECE38D325FAC47629
9E1940A6718753AC6AB86D0C2F54961CE2FA8956035877BC04A2A6CCC73F7D8B
3D82D5662A0E58CBDA9D8015AD00E21913561549D59579120E119021D3E4077C
C0C49D736C82BCB452E2F93BC5ECE2C1B198297E759699C3D533A1F381C5C6F8
D48F2D1C7E3BC77DF4025329F67D7C58AB25B33CD03C79C9926F7A120D3549BE
C2D8B44F8F9316ED5C00E7ADA71974E12ABCB895E0183954DBDE6AE05BE14275
AAABDC42F7A5179B5959399D4EE76EDE928EFB8B5BB461D32E33EA17DA379A03
5A33AEFCB5F468223E8908BC6F2B7D57169ED0F7A6F90C843AE02AC40DCAD730
688A090EF225F2D1798E2DCFCED6EAACFF91A368FD4D6D3F985C07AD665B4717
787DAD28FB46F721ADFF237E9135E51B5900B22E2EE1B5ED812CD2F3EC52CCA8
A6E6D00D459452FBC2A20D390C3EBFD7DA8918B0C7204F5999679E6B4B810591
C84398DF8AD94B194487B45B6B2EC3CD85FFE3D36A0C6C3AFCCCF206B2B60A27
1B585DF2178A45D32FA22E2333F9DAD4A3E47A532665D50202661E3C18CC3DE7
D205BD8A7EEFC4A5802510D3F3DA39C5F3F82BF14931BFA3347F9556B902EE84
4FAA2F32859E7D267372BE2512183A96C577044CC14073847B9729992A8A6438
AAAC7324595A421931A9483EA5156B8344F1CCDE84A46AB2CC7F0E518D99CFFB
EA5C549DEBD1A33C04ACFDA2CD5D8D8184AA8E08CA293E07BC5711AF7295AF4F
E6F42A5B5DD3510C003930CD8298A8E89952E3ACA0F996DD0A04ACF56C510324
6D0ED1EA283F58EDC99488B1A3EF45EFAA465CF5871F4D134CB163B519579E4D
521836E72BA8FD823AB6D9C24CA4B282C8E5F2DE58B324786E2E9D8CE00849C6
26586559ABAC804D860DB6E51173704DE35D983BB81052CDA91E844F5021898A
51705171C5EF1A5D265FDCB92E758CE82EAB07B0F6001D51AA41A1AB0E6CFB8D
50F3F41289F489346ECEEF86323A8C2B85B6508639FC3EAAEA0EFB073A407C9E
F6D513E132472DDC7C52A291E325AB358AB29FEEB045AC90C9EA0AAB9022A6C6
E67F9E62416D85AEDB5A7EF2E8BF6F6E21A391F2AF677D7FBC6085F33E0E9A0F
FC7D9AB0235E424A855CBD2A985B72700AF041145D2F709DD5C4C6A2BAE946A5
2091698D554F4734A354911091A94F8172F27ADFBDC0D2A5152262616DE4997D
1957E864A153B9B1F0033063A31172C84D93A55153FD322F816ED010912C5358
431C3D41AFDF84D8BD5565BE5CC90861F3ECFFAC4DD63DDDB367F34D81081C11
1B9BC5FA5D56B9736B48B2C8711D6DE38347AED4C284259B9984F46887536396
24B083E54D90203B43413D509138D5784451AEBB3A3A4D8203B43A032F0A9D57
2910AE98FA9E1A721F1AD90BAD865B291D4C286AAC333473E9615634097D0080
29BFB0B1255C71D033EAD4C2160A364D84F01A068A443914C795753EF9C88B30
6A2EC9471EAC9F2C02709DE409096B866260134116D47650F83C296A66648E0C
4E674BF56CF29D06E0FDEB52BB38F7505DB5CB8E742E3C0BFC25098B4CAEF07E
8AA3B4450D2E18FF31B9CE2A7DAAA94A475199D62E5D455E916C94A9AB3E9D95
35DD03854BA4A945AA17AB68D5CB662BE0B5180F65F6BEC194132666A36480C3
C8B62D424846D2ADCA3134984B6823FD2C0C1AFEDEEBF76634021B385D1761CC
6A69F94C190A54525AF22F1D189600FB6640D779925270B530B4C94657C52790
43B23AEF6DB434970C40D1FAD97EE9845339037E94AC89464C47A2633647BCF5
02A77F12506C02F1A02F1AE02E340EF2B25CC0615A7D58A46954C3005984F0BB
0B2B1D3E6BB803965A5C9F63FC20315678F283728378CC62D0E41D1316ACC89A
9A9721F60F13E2052366FB6445A68F8ED40B39AA924C980C2F5363892C70EEAB
9B4BAE1EDB9BC32021353F370B3587D622B308230D4C2BF1EFF4470582E82C15
B52378955AB0F7AFEDD20064A00691C608A8BF255BA64C898393959DF4063CEC
6270DC0C37FD9286F1DDD8F08E4877E4A44992594C69DF1C52A7126DD1467972
BB11E9F43852F953DAEC243FE25DC85F44E84ED069BCEB91DBBE8D91ECFDACB5
3C18F5228D9C3009BB595F95159048DD7AB511DEB7826C224C24C921027240D4
D09C951BD68B348A0C12FEFF5772DFA677FA57BBBA0E10BB4DF31221A0D3E8D9
4989A5D54FB7236008E0A47E38C339CAF82E19413C41B247F3F1976BA224CFD3
BF9E9219CD2CFAF3D7F5A651565F0F682F24890DBCE037952AD69AF7362AF0EA
CF15E6A12D40212C4350A9746BCE154C0D4C2F5D907251E9C589BBF1CBF88AFF
F5A5362BAAB8F50D5EAA8BFE9F953BF7AEC9090A4BD77FC107023E1F52279AE3
60A95AA08E5A7ABF3C3CF5443F03CF7C7A4EDD7BF3561811C56D78B9884CAACB
562DF44068595869BEA5988D29F9D548961D27DC0263223C0790C77D1FC7724F
9739E9BF74FA1570B5F7CCE5B766F5D2B487A03399B73D833A740751B1038FFA
A04742058FE11FAB0F843C23937159495138E4F025A6152C16C825D606C33DCA
06BB2114CBF511921C2D541101BE279FDAF309F24B757895A22A05BC54972509
0BFC15BC61EFD959E669C5535E0F9871E9E4550042CD2B51E1234E95040D3B07
F455C24E3FF29B8996EB94C76E03DC5BE364F559C5967A2DD3D65F56FC71DBD5
727F3697AC9EC0E7C98310BBA39C633B7C0CCE03897076A6AA9E0F475C9BE97E
647746E195655FCD1EC772F2D81C228420F35CBD9D7B09929FE7696EA51A97C5
77229F1264AEE839C973BDD3B3DEF8060D7DA006A2F4ADD949461DA9225354D9
D00AEDB19E5501DC3F0782AF68F8DEE9B0A86139AB52ED1559406EAE5CFC649F
B2888C65AE25BD9B3852C71FE1D42577951735AB30E65B349EA0B850CA3B28BA
7332F4540E579EA9DE9D79DB080E9B6A3F3EB3E3186E61A7313627CFD0FB2219
0BF56142DAC8630477C0DE111144672ADF31BDA828130145F296ACED40B80361
76E60A88B7B24C7FCDCD4BE7E258AA2BECD6D87C8A89D49A6986A70B5C33AED0
E39FD8BB62B3039DC126314700F5D37701D9C5FD0C0DCA99CA436114846D1792
0E6B366E652EC85B3EA82D31F31DB5D360304D45A5DCBDE532C9857825C183D7
94DBF5F6038F07FC10D735BA9AA1317F148B68211FB4DC80CB99E7BB26F825F8
A37088CDE271161FF04167E0FFF971DBE1A9D19E596A17174C26E28B27D37DA5
B22688404EAA653ED3D485899E599AE1711EAC252F6FC8F032182928CD90769C
4A60FB31D933BB7691F00B5703C0F08A048F29FAB54F53140ECF6A00528495C3
82E17641AD7F4A2235D1D31A7B724238D015D559E1593E1DF8C24EE061081D9E
0C55ACDBDE40B8532A9125C73831486D8792B4F4B099EB919A1D92B1C283896F
DA3C877A05B8C1B1C48ABA276A4A057ABF12800B42CD21BBAAD7F22D53EFCD38
D2B7CAABF3EEE295D7D147B0AC82523007DA819BA80BDE93087ED3F80509D10E
877B20E92EEA4D44E9F55577D929DC9CC6413D1CB46BFD3F496A0885272A5354
8760D60E9C47F24DF2217B9861E681D9A7E3CAD31F399868C99D30E2010D1ADA
DF1135C1AD236A093EF78B72B2DD013FB502F6ADF47C705C82B7A9EEDC4CF00E
6EED52626EC2C57D83CDBA13231129E7500A0100F197818DAFFCF0AD1F55CF22
3F3E6E4EDD8804F3A26127A5FF9E3762647B6C8F778E8EFDC9325768F8F36C6A
6A2E2B9B480CD24AC1EDF29A73C8B5449D14B1E478C3C86E52E40611D025EC65
7F47DE02CBA939ECD8418F4E838DEF4A387FA695EF7A5ED568D5B95B299499B7
49837278893FAFA4E6ACBF73F696D68DB013522D7BF9EB2541F38ED4E2751FF4
FB42AD5D6F2465D18F2525D85FA2343D8DA0089F451BBDC2D76C285617B0D434
CF47EC2A8BE6BA3524FF215824F68F2914E07976618737885194490F2D722E83
60986360863DD9C778254D2D1F45643DA5DA9369E89ADF83822F2CDBCA87A153
3DB0EDA646E184784E873AC972266AE6DAB6064D53156F57C23791B645C1C74E
55554E8CF3E58DAB3A00847CC1B654146AFBC5585C31DA3AB6444B89904515C8
518D80E84ABED150C666107C8A2B42557EF6A560CB40138AD0C3D3755ED6711F
11033F27ADA9A2CD89BAB8C0EC149AF3A7FD4FCA041CD83BC8D134CC963B5A5D
18C6ADCA84095B756D2522BC0C0E48A1D334992E49D7016CC28AACA1C469D82D
599F0C0EEB1F403143D132FC9354FC82547E9B496C3B5D656CF7C2011D60A37A
BDA298EA89EC3896FB5CEC12D33C10AA888C944F03FE04A62528116239C6C5BE
8ED9B5322275BF50B965513FE075521A8C0209E7A369C7C664CFBEFB5381872F
693579F9FB9F85943010A8FE1E1E71AA78A1F37F4B868B46CF35FB7DD6F8927D
49EFDCE931CD4F307109EBC9CBE6FDB0F9B92B62F1651ADACC91C1E3296AAF35
4359B2334B6D01123CB8E4CFA6CD7A9AFB5A70FE8DFDE7F7DA59A4B8DBB6040E
07C628ADFA0BBD27CC9BB7F6E09EE530BA1D9FE09883E39712D024EC6DA14E2B
9E1C74E667F1D7B9015E4C8FB71C86D99B69F6205D0EABDF01663308AE975B42
4834BA1C6DF455ED32F1F0507C8C99651414952348DA7AF58914F54313F10E76
507C173FC43847F0E1AC665A358233C33228538A342F66F836DE139284F658F5
DD908B0A7627151C0BEAB8275645120A7F2AE1AAFEC9BB84301E33B6987EC3B8
AD4C93076D40A8AE1A93141DEF3E4520AA121FAC9CE386116590BC6D09CF9E2F
D073701F4E07C03C04EE145CD2C4652DC518141E6BF044F5D89A36F3EE517820
9E8AB8931F1C92913B205CFA079EB57BC97A6CDDC866CD6CF68D352A3D2BBECC
617C0081D0504D7CF73986CD09D80569FAAE3D9A8ABD7295F45454E400C3E68E
280067FD5B133594EC513866D956CAA19053D4A493150A4581052B63B6600BA3
2E8139E79E32C1391BA053E407957B991F9B803766200E577D4DED551FE85697
8E06A67C93CE09EB4D6B19C51800E2D8DF337996BDDFB85EB29D402EE393F125
6AC33FE86346E3C9686CA3604C6AE3B80064D80458A56B7D55F03D8817D465D5
6803F51AD3C7015E35714FECC46CC6CAE184B4B27541988F8E37C732BE27010B
F75CB18A8052DBEA349465832765B86046AADD8EB21994448C1DA4991238045B
88F44FE217038A3A033342843C926F5F6AB373701920E9445F82D81CE2A83171
CF2BD29C2307454084818281D942B390692F6DDC36E4FF07A3CB267F989092B9
DD99C222A8853E8A160002B54AC63A9F4112FD7FE10D60AF90C8F438D4BDE48F
2840FDA10178E44CDC08B36E313A4C37A509E24533DA78807B1EDAC16E280496
04DCC8E810CC50CD74170F62339DDA62B7512ACD566455FCD74AC98BD8AEA47E
4AE492AFD20270E12D1DEEDAE0D53E90DD77DFD29BB99B3564DABBFB489A5D5A
14B059B2A00655F98B2F42C5B8272D4AEC8684359BC60EEC664C7BA67EF78D43
A89261385FCC39B53E6F9E5DE2D1F66C28E1A2604CDFC73251037165AA10A1EA
48E055AE8B031B08EF9229C04D4C6E222909211E814B5BB32AA47C18D442FD9E
99F94B35937A229CE21B9A14B05F45AAC734BBF26CE3BCC43EB44B277AF553DB
D5723A65B624B3E06745C8F08179B12BE424E44A1DB17D104C4CD7647490AD51
90DDFC3CA7C9670F3722561ABC5E3282E45AD2C0A9022947957AA9A7E7B1648E
9D483630D24F446E1ABF47D5BFC3204ED49F2CE1B55802DAF2FADE062DBD7CD7
7EB1E590E43480F0F3E2C2AAF32AA3C51D62F9858653C76BF1EA05FE1895D30A
733FDDAC0877BAD9DD2FAA088867E9C17BF2EE08F6B8D4228CF00ADB04BC1B29
8FEB53EBA1352BA4A931725098C8238E7DC2D3E7343CD254E7B0F0F7F02996F0
48A31C4F316F70A2604FEE68C1EF9CE0DC02BBBC852B8564E41B76E2535EFFE2
43981CCE9FAAE7A147535E8D4BEC1B8A3F0F223E6A0CC6A6EAAFF2DBD230220B
F99654305F720A8615F513B9FB602C342FA01C4F097C7FE33F62606A94CA1013
269AE4DD65209606EDBE2641AB03B6BC17A2E9AC54F1B90CACAB352B1EE10D73
032AFCBD594FD828589518538FED5A6FBBE404E2A5F6FF00D2F662E02ECFD75B
167576DA961A4C2451AA63AC4A5A3BEC9EB9329198F992D364F27F9AA276C907
8570392322B60ABEE429FB0699485950D9521A4018C5B1D1E6F80934F225F840
CEFEAAFEA848E691C1DE1B7CA4D8715AC50AA38A0AA669DE40A3B5689D3B8C5C
0B2D0DBB666F482849EB8B953C65CE771D390C6706F9AF52406BE71B86D35F23
912234DA3D2B0F977F1682D0F5DB8305CD2B0512E17DFBE7C5F78E6D99ECF7F3
8A31AA151879B5D2C95B1F6DF2AC047ACB40DFE1004711F95FFC7E4ABBAF4D68
A3D3565AA0CE8D74EBCA364FC9EFC84868AD49E3E103D4CBFDD66000181B0758
7537A2415ADF1F1D6A1121FD708A98E8EC8657683D0722F8F3F7246660608D9B
5F0E2186E272DB781E5E437C231331FA6F9E72C238A7BD0E5FD2E9D3B5C5E702
D39281A7C25A4CD9863CEA5E4E5409A41112EEFD6A3EE8B992E936651BCD254C
FA21D842719BEE2D586F5D1DAF0A3F09572C5C43A4F1D6DD0F02DC5120E7034E
1FD03753D0209B854A7E8DC216249FCF4E88F150A878174F735571866AC1F806
EB13CF9D036A8147EB7FBF3FDC61F018A55422AA23059F4CD561BFD0EFD69F85
056DF0ED391AAD9B03EEA129222BE57F8FEA5231FC9E4961E00A623F675634D4
F94DB4D82AC0887B57E1BC519A78856099209B9CE5CAABAADF0E1263B79159BE
99419C569A573A79CCDAB8C393444CFE87CC23D0CC831CC5C9941BD6A5871593
A7B74FF1D0E54A37BFA563565E75005F68598EEF2D404FC089CE1074C59BA470
606D6B3EE8EB8A9B15F981EE2183C21DF8E808E480C8673D5476C663B79E1646
B9614014F2B58F413058DD1E8BE9F6E8E9CCACE5F6A072F168B075148D4C3ED2
C90CD20A9C7EEECC087D030A79B71C2BA4F594F23C47D5DB3DB83F154D3B9909
2C8C02B37A70093A333809AF48F908419B7016DD709EEFFEBA06DAD2AF7ACAD2
0D87BCC164C237AA7DBEEFE263B5FB83E8BAF9435EB695B1B7410BB799ADFDF2
5709A8696D9923348F48B389D37BF926F1FA3166ADDB5CBB44363A3854501FC7
298E728D3BD1A7351C1463D50D42342167AAC20DA932BFA4FA71E3AAD6F4704C
489F0CD3E72D803879CDC69AA1920D8AD2F911FF42DF8F2251827A4902154E73
C92CCE3BAAEE1D7C7FBFB9FE6190E467EA0CA90AC3D4350A1D2629A0BF3A026F
6E3FD78756177FA1A6CDDBDE5CD4F9E52C44D8EE43DCB006FA1F5277EF22943D
1A98E0C835F4EE5418DE2618D69C466494971E32A9D94BC30F0517C66650E4FA
709C43F8C4605EBE9ADA836C39AEF3FF77045685E32502606D642F86FE39DD54
62BA30D79776C4E8F3C79819648E59DAC0EA3CACA4AE920B6D6F042BB6ED817F
2AF7191B77C473E31A73FA3B39C4C18EE58D80CB40CEF43F047AEB2663C41EED
FEC6FC09870C49D9A5F2FE6A5F23081191152C01A7DF2E63CC97768FB56853C6
F4557D4A4C5D0355F8B4A7333458094A2C3B8B51CDC1874610A1E5FA977FB063
85777E2E37B10ED47D8BC759D34FD9801B8A640D409779314E30DDEE8929D891
D64047A5758ADB937DDD11D6091B203021EC68DE41BF99512921346A87A210F3
1C7F37FA77D390A0ADFFFBA51E499C4D3A66CD275EFBADC0B99B545037A4B619
4241C60B5E531EDDCE52FD6B4FC4A738C024E76E2DB54D66BCF146221638F93B
29D9C14FE5D94223F345DE0197E53E0ABC54142D17F978095AFD28A078885043
E4F830DFDC2DA72763CCD191D2D45162E76448D1CD15585EAD3D0D9D238D486C
55A00798C6F1892DB9EF886FB664A3E13C485F2CC8E86EF1E9E0330EEF63D681
23F899F1164FAB22AA6542E7A9C01FDD1CAFE089CC39AEA4A2F96FB391F548CD
33BEDBC3948CF526AB2A32A53DE66D5BB33F79063A1983C9628290E1157503F2
0DBB95F71AF416DB4E5D6BC03124C88CF9543DDB2697B15151088234AA8FC5CF
EB18813EC26E35D71C7A0797DFC4CFB357A633A3DD3835E99FD03ADA152A9B36
B75608CA4B6D06E1487873D5649526F93E9C4C13F1F255717EFDE079EDD6F3AF
A77C2C4F9B44EDA7AEC445AD6EC7A0919190F3B4A957639788C06A6F8FE98675
50C0BDFF62AA12682DA8421B30418C34DB5099670D442392242981E9AD0588BF
E9EE1C319492DDEDA9FD5B315269380DC607346F415D4CB30E37F8E21ACD2D5C
2AA41D07CEFE019A1EF1B0B0749E05027D5493A806A353E32C0A99B96BB6D86B
6EEADE7CFB8F7AC6F30DC0D06173F6204EC9BDF606FB71F8026DC4A2F18BAEBA
E13EBD5CABAD700A47C3C77EF58169CB812D659EEEA6993EE193DB060A2B0E5D
E01ED3970DE186AB443D6FE0697C68B18CAF3A10FCAA3DF6282568C0C11AB481
381B58AEF4C107B33C123E68109B182AB7B0C0E8F6106A6DCD89B881AA5DD8D1
AFFB0E12D6A78950B92F7579132B9C12CB0411A5DC3B55B5BBF0EB78928BC794
C0125A23EF1DA1C4DF97A1B435BC1AE23B20461683A46FA45890FEBA0F57004F
17C90B1F9BCC47639B90933AAA733CC8ECE6D689B0AABE2F05A37F0816B9EBB8
200F2AB7DE32188067FFC9BAA376A98B1EEE9EDBE9205C3709C5AD71487B4B93
F9E9E6FDE07B162D1790A2EE9A9373EF934E4C61DED60F0FB05F65D0FD75CC7F
BA6B929E0F7E4E76C1711CD9198E5134A27E8A5A106D86E395ADE5084DBC6CD9
67182D07C139A2F87C2614D35DC17DA2DF671C74B269778B7044767539CBE1B2
7B8DE36E8E9E8B6CEBA8FB765C4A0D1E660F9C7B0ED504E74A5FA95B1DDBDEAF
105C82D7A6A483EE637A8537596710EBC36AB1395806EBC72923899A0FB79F81
13D20D80650F41D114DE37C4638E374100814359F69CC9C66A93AFD1E80B1173
529372A571F310D729B4B96A754815E2259431C056A31AB79FC3F1817D746080
1E9AAA88112BD73EBC1037EFB5D63F8646A2A49D11A3598667035DE23F89AD59
89EEBAF798B72E55A80C4F8BC5937B4D74BB5FB94ACC38F8781FB5591A7F2AD0
6A7DF7557128CDF1022AF48BD7A79B50B73111CF491A652F23449EAC2616DE8E
DDDAC7860D4E95225E5552C6FCE838441FD95E2CB2C1DBFEAC0256D2E2C3C470
40AFC2F3BF53B6E6ED879EBB382013A7C7A14CF7BC731E996F431C318824F606
95B109A67D0C27874555F5FCF839B2E73E6B678024980A870611BBB8C427C9B1
79E92371A2D276F8A913F021D5731F0E3952DA5E9548EEFB4CC5935DCD27F3E6
BB3E577F55FE874AD1F4EC8EE7A12DE954F33ABC500F6BFE49D430736EA9E5B5
1A084F8910F0C098FF0B9020AAF617B3E23385030381B7E121247087E8D6A785
6B50F4D85EC9CE47B0DDD992CB76C468E66BAB79F4838E6CC629EBC1CF0D22F2
619771EBB353381DA8DD36AEE9412817B4F49C098DEC1C52A23BBC5C4795BF2D
0F78A56E8BC70CC289F5465E0AB488941F6211FC4C15E0320A28A746D6541141
78488E0693357EB6D4A0D23D46BCBF420A5E8EFE21A8EB583A3A5B525F626712
71DC667A4981400C1E0A386CE4F26F98E001AA58D88EA6B71D921D1472C11112
A7F9C2C9AA5D61EDB0BF3985C89E7DF55DD84C0643D10D72098E7BCDDA43A267
F6FF131C4AD47624F4CCAD3A1E43EBFC161D83432788C56658F8A5B7C78591CB
F1DF0118CB4D877677B99B1C1EEB46047941C704DF78A9D496123C741C412E87
8F5777DB0835A88891350E82E7C850FE5CEF680EA6235DC4A730CFB913F79C58
9D42AC94EF8FDB475A62378C5E32734020122FFBB3AF32A3B171900DC2D7DAB1
285A6F55D28ABE64B95FB1229FCA09BA8E7E1D353EC422E6EA1C5FFECD38BD74
062CE577C3D7DA863B49D02C0F74488269A1EB760E7C1EE8B595C2897EA704C4
728208DD73E43276E26B97C775D5195007BC6B7310075B71D491F94995FF72D2
40D7A5B62BFC7A8D8A71EFE969306FEE61E6A84CF393E8824EF7B6477B447B57
24EB126E69CF77E92D6A0B3AABD3A634773E911B94324F6B1195E9919B36DA5F
431EDDA4FED6AACE35CFB62289F1F86663B11AE353E86B569621F612FD9D54C8
73D498925F302F91FE3723A9F143CB84CE445C2F674221B2B759303D719C5D61
27AAC1D13DB4C022BFAE0E9894B4B7CD08C5C04746684798973882AB0AF19AA7
EA8505C1DF9AAA0D7CFF37E22B596159FB12592C85D8F9079B1346C21DE0A02E
05276F9D65893613A3599A205EA3E3365C5DFC1772F34B563F44973BBB8AF73A
E766C76612A6657B5775CF36A68C3FFB6CCD8C58E65B1F696E5A34DBA1386CA9
0E5C53733DEE162D9E939520D3F6626533575E6670E02C29B9EC320A790587EA
28E438A68A555C32E306036D93CCB38CA306357C3D83D8309DC8C1AE51590207
4793FCB06D31D51036434A0EE02C71587ADC3568866534AC480A2B0935D843F4
D99FECAD6F6710933550FB02F8918F8FE1A7B7822FF9A0352B6FE2EFF42AA2DA
79C91A511679E5437E25B94392FFEFCFBD1CCD4E8F67893AA7E146E1AB91A460
5EDD3D33813A23C2071D1EDF7BBADC441C096E1B3D3BF0D63DD97B582FFF61FB
47BE74D73B374379824C00DEE179683B8398437319AF419394248F4AE376B4E0
16B7AD33FC2AA0EC14A8A74B417ABA54A9F5042089D04ECB878018C020CEBA81
D40887EB3CA75A521075CD8320266388EEFE026732BF61442EA3D11037B8FB9E
8993DDE914084F44471B20BEF5623EBA1D96F0233D3A3CA29826F8951D13BCD8
BBFA1E60A907BA50F6C99BD3EBB617CCB9B6F432D0F2406683EBA61C30FDA4F9
A4A116C2E49F96D3F8402AD365B0C533324AFC5967BF08CF5552539D1A04F072
E96750F55254B3E9C304B1911BD40D502C48DC9EC9DC717811FCFF402D7F3F7A
E15164776E5B6A42342DCBBD66358D7EFBE7FD31FFAEF749A07993448CAD01D8
9EC169F147CBB36D19E42E3E8DEF1EE0D41E9D1F022BC1917BC5A36BBE298C81
14E84168D1AE93D99A2BF39D9EFB2A242F033CD86B0D747E3A7D71F9DE9108EA
7EAA6F0C36FF97F775206642D443C9ED6FE743F885CA7E9022434FF21007867A
E3355A8C2DC84602FF0B732DC4EF41D85F83E91629D9BAD3A9C767537CF3B86B
D048A61E45E305D7134CA63519767CA5AA1D8E8871B54679C3B034DF9A51FC53
0CB7F1F8651F512B51683D91C139B738AB7C566268982EFBE9EE
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 6421040 10150399 1000 600 600 (aufkl_motor.dvi)
@start /Fa 173[52 8[25 3[48 54 16[35 35 35 49[{
 T1Encoding ReEncodeFont }7 66.4176 /SFRM0800 rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
% dvips-unknown
statusdict /setpageparams known { hsize vsize 0 1 statusdict begin {
setpageparams } stopped end } { true } ifelse { statusdict /setpage known
{ hsize vsize 1 statusdict begin { setpage } stopped pop end } if } if
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop 0 TeXcolorgray Black 0 TeXcolorgray
-600 -600 a
 /pssetRGBcolor /setrgbcolor load def /pssetCMYKcolor /setcmykcolor
load def /pssetGraycolor /setgray load def
 -600 -600 a -600 -600 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 -600 -600 a -600
-600 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 -600 -600 a
%%HiResBoundingBox: 0 0 97.97733pt 154.88284pt

%%PageBoundingBox: 0 0 98 155
%%HiResPageBoundingBox: 0 0 97.61104 154.30382
%%BeginPageSetup
<< /PageSize [97.61104 154.30382] >> setpagedevice
0 0 bop
%%EndPageSetup
 0 TeXcolorgray 0 TeXcolorgray -500
161 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.85355 SLW 0.92 0.92 0.92  setrgbcolor   0.3 true 36.98865 73.9773
0.0 -11.38092 .5 Frame  gsave 0.98 0.98 0.98  setrgbcolor  1. .setopacityalpha
 fill  grestore gsave 0.85355 SLW 0.92 0.92 0.92  setrgbcolor  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial -500 161
a
tx@Dict begin  { 4.26773 57.81593 } PutCoor PutBegin  end
 -500 161 a 23 w Fa(DIR)24 b(2)-500 161 y
tx@Dict begin  PutEnd  end
 -500 161 a
-500 161 a
tx@Dict begin  { 4.26773 50.58899 } PutCoor PutBegin  end
 -500 161 a 23 w Fa(DIR)g(1)-500 161 y
tx@Dict begin  PutEnd  end
 -500
161 a -500 161 a
tx@Dict begin  { 4.26773 43.36205 } PutCoor PutBegin  end
 -500 161 a Fa(E)f(3)-500 161 y
tx@Dict begin  PutEnd  end
 -500
161 a -500 161 a
tx@Dict begin  { 4.26773 36.13512 } PutCoor PutBegin  end
 -500 161 a 23 w Fa(DIR)h(2)-500 161
y
tx@Dict begin  PutEnd  end
 -500 161 a -500 161 a
tx@Dict begin  { 4.26773 28.90817 } PutCoor PutBegin  end
 -500 161 a 23 w Fa(DIR)g(1)-500
161 y
tx@Dict begin  PutEnd  end
 -500 161 a -500 161 a
tx@Dict begin  { 4.26773 21.6808 } PutCoor PutBegin  end
 -500 161 a Fa(E)f(2)-500
161 y
tx@Dict begin  PutEnd  end
 -500 161 a -500 161 a
tx@Dict begin  { 4.26773 14.45387 } PutCoor PutBegin  end
 -500 161 a 23 w Fa(DIR)h(2)-500
161 y
tx@Dict begin  PutEnd  end
 -500 161 a -500 161 a
tx@Dict begin  { 4.26773 7.22693 } PutCoor PutBegin  end
 -500 161 a 23 w Fa(DIR)g(1)-500
161 y
tx@Dict begin  PutEnd  end
 -500 161 a -500 161 a
tx@Dict begin  { 4.26773 0.0 } PutCoor PutBegin  end
 -500 161 a Fa(E)f(1)-500
161 y
tx@Dict begin  PutEnd  end
 -500 161 a 0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray
0 TeXcolorgray eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
