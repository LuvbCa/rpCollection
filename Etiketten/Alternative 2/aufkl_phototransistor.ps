%!PS-Adobe-2.0
%%Creator: dvips(k) 5.996 Copyright 2016 Radical Eye Software
%%Title: aufkl_phototransistor.dvi
%%CreationDate: Mon Oct 17 18:57:53 2016
%%Pages: 1
%%PageOrder: Ascend
%%BoundingBox: 0 0 92 126
%%DocumentFonts: SFRM0800
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips aufkl_phototransistor
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2016.10.17:1857
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 919 2014-05-19 18:42:47Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.24, 2016/04/22
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionary
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/Log { dup 1e-20 lt { pop -1e30 }{ log } ifelse } def % control the log
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/Acos2 { 2 dict begin 
  /x ED /y ED
  y abs 1.0e-20 lt { 1.0e30 } if
  x y div 
  dup dup mul neg 1 add dup 0 lt {		% arc cos needs two values x,y
  pop pop 0 }{ sqrt exch atan} ifelse 
  y 0 lt { 180 add } if
} def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def % Polar to Cartesian
/PtoCab { dup cos 4 -1 roll mul 3 1 roll sin mul } def % Polar to Cartesian (Ellipse) a b phi-> x y 
%/Rand { rand 4294967295 div } def		% a real random number
/Rand { rand 2147483447 div } def		% a real random number between 0 and 1
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%
/startGlobal { true setglobal globaldict begin } bind def
/endGlobal { end false setglobal } bind def
/pssetRGBcolor /setrgbcolor load def
/pssetCMYKcolor /setcmykcolor load def
/pssetGraycolor /setgray load def
%
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  /Scale ED
%  1 exch div round /penroseFactor ED 
%  a 0 dtransform round exch round exch
%  2 copy idtransform 
%  exch Atan rotate 
%  idtransform pop /a ED 
%  .25 .25 itransform pathbbox 
%  /y2 ED 
%  a Div ceiling cvi /x2 ED /y1 ED 
%  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
gsave
  220 150 translate
  Scale dup scale
  systemdict /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
%  pop pop 
} def
%
/PenroseFillA {%  on stack: scaling factor, border color, kite color, dart color
  /Scale ED
  Scale dup scale
  /border_colour ED 
  /kite_colour ED 
  /dart_colour ED
  clip 
  newpath 
  gsave
  100 100 translate
  6 
  Scale 1 lt { 1 Scale dup add div mul cvi } if %%%%   Number of iterations
  10					%%%%   Long side length in millimeters
  /border_width { L 0.06 mul }def		%%%%   Choose the scalefactor for the borders
  /L exch 25.4 div 72 mul def		%%%%   Conversion: mm -> inches -> points
  /f{-1 5 sqrt add 2 div}bind def		%%%%   The reciprocal of the golden ratio
  /l{L f mul}bind def			%%%%   Short side length l = L*f
  /Ll{L l add}bind def			%%%%   Ll =  L + l
  /c{36 cos L mul}bind def		%%%%   c  =  L*cos(36)
  /s{36 sin L mul}bind def		%%%%   s  =  L*sin(36)
  /draw_tile { 0 0 moveto c s lineto 0 lineto gsave closepath gsave fill grestore
	     0 setlinewidth stroke grestore border_colour stroke } bind def
  /half_kite { dup dup 0 gt{ 1 sub gsave f f neg scale -36 rotate half_dart
			   Ll 0 translate 144 rotate kite grestore }
	      		 { kite_colour L draw_tile }ifelse
	     pop } bind def
  /half_dart { dup dup 0 gt{ 1 sub gsave f f scale half_kite
			   -144 rotate Ll neg 0 translate half_dart grestore }
	      		 { dart_colour l draw_tile }ifelse
  	     pop } bind def
  /kite{ gsave half_kite 1 -1 scale half_kite grestore }bind def
  border_width setlinewidth  1 setlinejoin  1 setlinecap
%  450 0 translate  
  dup f exch neg exp dup scale
  5 {kite 72 rotate } repeat stroke 
  grestore
} def
%
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/CalcBezierSpline {%  Christoph Bersch
  10 dict begin
  /getX { Points exch 2 mul get } def
  /getY { Points exch 2 mul 1 add get } def
  /n Points length 1 sub 2 idiv def
  /GetFirstControlPoints {
    /x n array def
    /tmp n array def
    /b 2 def
    x 0 rhs 0 get b div put
    1 1 n 1 sub {
      /i exch def
      tmp i 1 b div dup 4 1 roll put
      i n 1 sub lt { 4 }{ 3.5 } ifelse exch sub /b exch def
      x i rhs i get x i 1 sub get sub b div put
    } for
    1 1 n 1 sub {
      n exch sub
      dup dup x exch 1 sub 2 copy 6 2 roll
      get 3 1 roll tmp exch get
      exch x exch get mul sub
      put	
    } for
    x
  } def
  % 
  n 1 eq {
    0 getX 2 mul 1 getX add 3 div
    0 getY 2 mul 1 getY add 3 div
    exch dup 3 1 roll 2 mul 0 getX sub
    exch dup 3 1 roll 2 mul 0 getY sub
    [ 0 getX 0 getY 7 3 roll 1 getX 1 getY ] /outPoints exch def
  } {
    /outPoints 6 n mul 2 add array def
    0 1 n {
      dup dup 6 mul dup 1 add
      outPoints exch 5 -1 roll getY put
      outPoints exch 3 -1 roll getX put
    } for
    /rhs n array def
    1 1 n 2 sub {
      rhs exch dup dup getX 4 mul exch 1 add getX 2 mul add put
    } for
    rhs 0 0 getX 1 getX 2 mul add put
    rhs n 1 sub dup getX 8 mul n getX add 2 div put
    GetFirstControlPoints
    1 1 n 2 sub {
      rhs exch dup dup getY 4 mul exch 1 add getY 2 mul add put
    } for
    rhs 0 0 getY 1 getY 2 mul add put
    rhs n 1 sub dup getY 8 mul n getY add 2 div put
    GetFirstControlPoints
    0 1 n 1 sub {
      /i exch def
      2 copy
      i get outPoints 6 i mul 3 add 3 -1 roll put
      i get outPoints 6 i mul 2 add 3 -1 roll put
      2 copy
      i n 1 sub lt {
        i 1 add get i 1 add getY 2 mul exch sub outPoints 6 i mul 5 add 3 -1 roll put
        i 1 add get i 1 add getX 2 mul exch sub outPoints 6 i mul 4 add 3 -1 roll put
      }{
        n 1 sub get n getY add 2 div outPoints 6 n 1 sub mul 5 add 3 -1 roll put
        n 1 sub get n getX add 2 div outPoints 6 n 1 sub mul 4 add 3 -1 roll put
      } ifelse
    } for
    pop pop
  } ifelse
  outPoints
  end
} def
/Spline {
  /showpoints ED
  counttomark 2 div dup cvi /n ED
  n eq not { exch pop } if
  ] /Points ED
  n 1 gt {
    CalcBezierSpline
    mark exch aload pop
    ArrowA
    n 2 sub {
      6 2 roll 4 2 roll curveto
    } repeat
    6 2 roll 4 2 roll ArrowB curveto
  } if
} def
/OpenSymbolSpline {
  Spline
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
%
/isbool { type (booleantype) cvn eq } def
%
/Ellipse { 
  dup isbool { /MoveToStart ED }{ /MoveToStart false def }ifelse  % false or true
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 
  MoveToStart { 0 0 moveto 1 0 rmoveto } if  % move to the start position
  0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput {
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  5 dict begin
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 919 2014-05-19 18:42:47Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.07, 2014/08/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
%currentdict /Pi known not { /Pi 3.14159265359 def } if
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
/I2P { AlgParser cvx exec } def  % Infix to Postfix
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length 3.1415926 /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_floor {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 842 2013-10-26 10:25:41Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.04, 2013/10/26
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
/ps@ReverseOrderOfPoints { % on stack [P1 P2 P3 ...Pn]=>[Pn,Pn-1,...,P2,P1]
  5 dict begin       % all local
  aload length /n ED % number of coors
  n 2 div cvi /m ED  % number of Points
  /n1 n def
  m { n1 2 roll /n1 n1 2 sub def } repeat
  n array astore
  end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
/rightTrim { % on stack the string and the character number to be stripped  
  /charNo exch def
  dup
  length 1 sub -1 0 { 
    /i exch def dup i get charNo ne { exit } if 
  } for
  0 i 1 add getinterval
  dup length string copy
} bind def  % leaves the stripped string on the stack

/psStringwidth /stringwidth load def
/psShow /show load def

%/stringwidth{ 32 rightTrim psStringwidth } bind def

%/show { 32 rightTrim psShow } bind def
%-----------------------------------------------------------------------------%

/pgffunctions {
    /pgfsc{}bind def% stroke color is empty by default
    /pgffc{}bind def% fill color is empty by default
    /pgfstr{stroke}bind def%
    /pgffill{fill}bind def%
    /pgfeofill{eofill}bind def%
    /pgfe{a dup 0 rlineto exch 0 exch rlineto neg 0 rlineto closepath}bind def% rectangle
    /pgfw{setlinewidth}bind def% setlinewidth
    /pgfs{save pgfpd 72 Resolution div 72 VResolution div neg scale 
      magscale{1 DVImag div dup scale}if 
      pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind def% save
    /pgfr{pgfsd restore}bind def %restore
    userdict begin%
    /pgfo{pgfsd /pgfx currentpoint /pgfy exch def def @beginspecial}bind def %open
    /pgfc{newpath @endspecial pgfpd}bind def %close
    /pgfsd{globaldict /pgfdelta /delta where {pop delta} {0} ifelse put}bind def% save delta
    /pgfpd{/delta globaldict /pgfdelta get def}bind def % put delta
    /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse % install .setopacityalpha 
    /.pgfsetfillopacityalpha{/pgffoa exch def
      /pgffill{gsave pgffoa .setopacityalpha fill 1 .setopacityalpha newpath fill grestore newpath}bind def
      /pgfeofill{gsave pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore newpath}bind def}bind def
    /.pgfsetstrokeopacityalpha{/pgfsoa exch def /pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind def}bind def
    /pgffoa 1 def
    /pgfsoa 1 def
    end
} def
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 801 2013-07-09 18:10:41Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: cm-super-t1.enc 0 0
% This file is generated from `T1uni.map' and `glyphlist.txt', `gl-other.txt'
%
% LIGKERN hyphen hyphen =: endash ; endash hyphen =: emdash ;
% LIGKERN quoteleft quoteleft =: quotedblleft ;
% LIGKERN quoteright quoteright =: quotedblright ;
% LIGKERN comma comma =: quotedblbase ; less less =: guillemotleft ;
% LIGKERN greater greater =: guillemotright ;
% LIGKERN f f =: ff ; f i =: fi ; f l =: fl ; ff i =: ffi ; ff l =: ffl ;
%
% LIGKERN space {} * ; * {} space ; zero {} * ; * {} zero ;
% LIGKERN one {} * ; * {} one ; two {} * ; * {} two ;
% LIGKERN three {} * ; * {} three ; four {} * ; * {} four ;
% LIGKERN five {} * ; * {} five ; six {} * ; * {} six ;
% LIGKERN seven {} * ; * {} seven ; eight {} * ; * {} eight ;
% LIGKERN nine {} * ; * {} nine ;
%
/T1Encoding [
% 0x00
/grave
/acute
/circumflex
/tilde
/dieresis
/hungarumlaut
/ring
/caron
/breve
/macron
/dotaccent
/cedilla
/ogonek
/quotesinglbase
/guilsinglleft
/guilsinglright
% 0x10
/quotedblleft
/quotedblright
/quotedblbase
/guillemotleft
/guillemotright
/endash
/emdash
/afii61664
/perthousandzero % PERTHOUSAND ZERO
/dotlessi
/dotlessj
/ff
/fi
/fl
/ffi
/ffl
% 0x20
/uni2423
/exclam
/quotedbl
/numbersign
/dollar
/percent
/ampersand
/quoteright
/parenleft
/parenright
/asterisk
/plus
/comma
/hyphen
/period
/slash
% 0x30
/zero
/one
/two
/three
/four
/five
/six
/seven
/eight
/nine
/colon
/semicolon
/less
/equal
/greater
/question
% 0x40
/at
/A
/B
/C
/D
/E
/F
/G
/H
/I
/J
/K
/L
/M
/N
/O
% 0x50
/P
/Q
/R
/S
/T
/U
/V
/W
/X
/Y
/Z
/bracketleft
/backslash
/bracketright
/asciicircum
/underscore
% 0x60
/quoteleft
/a
/b
/c
/d
/e
/f
/g
/h
/i
/j
/k
/l
/m
/n
/o
% 0x70
/p
/q
/r
/s
/t
/u
/v
/w
/x
/y
/z
/braceleft
/bar
/braceright
/asciitilde
/hyphen.alt % HANGING HYPHEN
% 0x80
/Abreve
/Aogonek
/Cacute
/Ccaron
/Dcaron
/Ecaron
/Eogonek
/Gbreve
/Lacute
/Lcaron
/Lslash
/Nacute
/Ncaron
/Eng
/Ohungarumlaut
/Racute
% 0x90
/Rcaron
/Sacute
/Scaron
/Scedilla
/Tcaron
/Tcommaaccent
/Uhungarumlaut
/Uring
/Ydieresis
/Zacute
/Zcaron
/Zdotaccent
/IJ
/Idotaccent
/dcroat
/section
% 0xA0
/abreve
/aogonek
/cacute
/ccaron
/dcaron
/ecaron
/eogonek
/gbreve
/lacute
/lcaron
/lslash
/nacute
/ncaron
/eng
/ohungarumlaut
/racute
% 0xB0
/rcaron
/sacute
/scaron
/scedilla
/tcaron
/tcommaaccent
/uhungarumlaut
/uring
/ydieresis
/zacute
/zcaron
/zdotaccent
/ij
/exclamdown
/questiondown
/sterling
% 0xC0
/Agrave
/Aacute
/Acircumflex
/Atilde
/Adieresis
/Aring
/AE
/Ccedilla
/Egrave
/Eacute
/Ecircumflex
/Edieresis
/Igrave
/Iacute
/Icircumflex
/Idieresis
% 0xD0
/Eth
/Ntilde
/Ograve
/Oacute
/Ocircumflex
/Otilde
/Odieresis
/OE
/Oslash
/Ugrave
/Uacute
/Ucircumflex
/Udieresis
/Yacute
/Thorn
/SS % Germandbls
% 0xE0
/agrave
/aacute
/acircumflex
/atilde
/adieresis
/aring
/ae
/ccedilla
/egrave
/eacute
/ecircumflex
/edieresis
/igrave
/iacute
/icircumflex
/idieresis
% 0xF0
/eth
/ntilde
/ograve
/oacute
/ocircumflex
/otilde
/odieresis
/oe
/oslash
/ugrave
/uacute
/ucircumflex
/udieresis
/yacute
/thorn
/germandbls % or /germandbls.alt
] def

%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/@beginspecial{SDict begin/SpecialSave save N gsave
normalscale currentpoint TR @SpecialDefaults count/ocount X/dcount
countdictstack N}N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto
0 vs rlineto hs neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale
ang rotate rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}
ifelse scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale
llx neg lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly
lineto urx ury lineto llx ury lineto closepath clip}if/showpage{}N
/erasepage{}N/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{
count ocount sub{pop}repeat countdictstack dcount sub{end}repeat
grestore SpecialSave restore end}N/@defspecial{SDict begin}N
/@fedspecial{end}B/li{lineto}B/rl{rlineto}B/rc{rcurveto}B/np{/SaveX
currentpoint/SaveY X N 1 setlinecap newpath}N/st{stroke SaveX SaveY
moveto}N/fil{fill SaveX SaveY moveto}N/ellipse{/endangle X/startangle X
/yrad X/xrad X/savematrix matrix currentmatrix N TR xrad yrad scale 0 0
1 startangle endangle arc savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
%%BeginFont: SFRM0800
%!FontType1-1.0: SFRM0800 0.3
%%CreationDate: Wed Sep 12 2001
% Copyright (c) 2001 Vladimir Volovich <vvv@vsu.ru>.
% See the file COPYING (GNU General Public License) for license conditions.
% Converted from METAFONT EC/TC and LH fonts:
% ecrm0800, tcrm0800, larm0800, lbrm0800, lcrm0800, rxrm0800.
11 dict begin
/FontInfo 6 dict dup begin
/version (0.3) def
/FullName (Computer Modern Roman) def
/FamilyName (Computer Modern) def
/ItalicAngle 0 def
/isFixedPitch false def
/Weight (Medium) def
end readonly def
/FontName /SFRM0800 def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] def
/FontBBox{-203 -320 1554 938}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA052BD0CE60552BD63101D7CDBEEF5B11
69C468645FE4ED1AF2541AA0770C1DCF81623DE0ECDF49F2B522618F650CE6CB
CC8C21885DD61AF8A523AA677EAEDDFA51A1F9B1885EEE0456196D634E04EF89
F17499DAD982502ACC349B9EEAAE4A71A73D1147318C60A8BAC10510DE90D8D3
F46E47295D27129A5AFE0C65E22BAD10D06885A2EE623FF8E1D90287A083E00C
EF25195F68A2A98170E48759F33528B839DFD4B92DF0482493852D12053A7904
BF6E144B948894BA0E437691D4618A0FFB62E3630B93DD190EBC8F306BB78955
34955AD847F95B1923B90644A4707B718BCB527F8D5F617EC559C70A91900E72
9A9D881D02E289B0B0725B43F5FE653ECE8C5F062BD2C10F4B9B0ED3938F84D7
FD5D3725C3F438E46A270FD43270689A5F30B1FD8CD61E7CB544F07FE57D719E
17CB8A7A146AC514A35380CC6D93840A2DCFBE40307F2FFD8AFC0E54D066DAFC
025AD2A93593551D363563A2208329634F6BD80400775EA44ED4F59B0F767946
25D1A692A6C9197B50C369ADC30DACF14BB7FBF9EFA9AC4894FE3E0A6B3245B0
7E7353569A285310D32E52C36FE2A2827319227E0B024A615243399486706FF6
9E76827C1ED6ED10CA2C9E369D5A507991070CB699F666AFA47FB9EE3D968112
38D5F4624378D9B34F8B00E280EA3F61E4CB33EDCC35F0433A4EF6D267C08A0C
5D5A95A531D8A0E1DB1394DA5F72EF2ACE4CFDF20871C679418FB1B481CC5EAC
C1733601DE79FE5D9B793234D4DE58546A5068CACB9EB1D82644358DAE105ED7
BAAF89A47AF526E481D3E105141FC7EB61A5E5602412613D25A39EFCD8AC6ECB
1ED92210690BA38F6A1E1D49AF1B6C8D7904633F0CA55E1E951E9BEED4339DE1
5C97307776C6238E3C3749F55276DE11C29565BC5914A12E414818AB259FFDF6
EFDA0F520257D55915532D048497C4A45E813004BA89D16F34E847E14FB85C6D
F655651F7F8F93BB3B8BF3D37D4BEE651C58CE6F89A0E4A039F7672039ACC235
797D06645170342BF3F67146194DD1FA79F2A5879C5E9546B2A3698E3F716527
D480F7B35F92ED9E284CCD6B344555843F4697DA8ED586320141BA36D5C3AC01
D34F8800522E4154E66120234EA715800AD9A9B7AF56296934D0377F7FE0FB41
B994AD131029C4A51B6AC1BAA22C0A5564547A9F05D5BA7EBC2C184831B46490
CE0F1C4EF1ED2387628BB7B0527FEB50212522C8D4156C9152A59D68D0704585
B969251F67BEBCD432452696E15D7C3D781959DAB1F20D320C6496DDFF0E73C1
6B94578EC769DA4EDD9F342275BF50B965513FE075521A8C020F9A3AA806F512
E976E351613F23E810E4DA5FD336C660B2D06585EF6D1A99402DD795317EA4E7
786D750C09528DDF1BC70C66D1F3B544E7C1D64DCEAB7476A2E394518D3B7085
CDB8B755057EE574A158761FA7F6FF3081DC39F81477A8BCF7C9E71F26E4FF8E
D3F35B5FA5BD6D0F4E85EEC43ACB5569CEDF46D479F1361AF8C72F0116C1AE65
B5769470BB43DE8DD9B41B05DE74ADEE20EF53751328E391BA0A83699AFDAB98
39261F94F3172250DCE97CFFDDC72835A46F4CA8FA0A2A98C9BF237704BEE908
4547F0AB1BBCA5345ACF706FF4096445A087B13F6BA87C92E8EE22AA8B1D324C
FB407059F595DE66EE6407CA92FF940D5C2EA0707CEABD8F2BAF1C80D8BFDAFF
758C9E8706E8C944274A1D9CE79A9A319C6559B46661FA8BF8A6B340679F9423
11B1018F6210E7BF228137652ED54DE66F7844DD74DFBBA3C4339634DAB87319
E9E3072D79559B33C05412CBACF296E30EBC12722EACF48594016B4B9C30CC1B
8E826C6FF5F775F9A14B2E70FBC38D6D3AA58780190F135901882D75D1C1FB40
D06B955B1E11897D5CD320995D0873F607C5FC4459744016FE0B3D2BA9BCFC6E
40DC39A24FD0F31FE8A94F1A515BD7A9B8923061CD16B6AB1774BE2256A995E3
C2F0AB3B2B7D233FC29C3822DE5DD1D98664245056238422268ADA4EA95315C7
14D1CD3A80C0AB9562133BA2AF5597592B3816CD777C55A2E36F61EF76AC6D76
BA75C0EE14BA0A9142B05B2B85301E6EEF72E5949236930BC41432A9CFF554B8
4C9A4373F20D95B61A9E7E90665633A83E7F9C5E2F62303F3533CFBCEC9A2D13
D426B95F0EF5022436D6A5171E4D5FE3010E26CF97B8EB2D0EDDCF65254BBD87
B538A8BDC93D4009C2ED9FD00797AEE5169BAE41BF05899772E4D7CE48276DE9
EB064FA545841C4E2802C3E67B20B98842A0DE224CB112894CD29588B5AB84F7
4FE3EDF6E48B9AB4C904556AD2695644AC890E05A8E6A0F94C6F1D948D8BB487
C825E7D9AC7D0D86B75F5E18C430D828A7C16A81002AE7A643482B4529D90457
FABEDD3CF1971308515E9151219C86CB4597F46AAE7CE33D9440333E343C1044
50F9A59E02997BE90DA8E48524A513FA04C776B1AFBF0CEFA5117040491E3E4F
8D2C91EF44D49E1A9F4F381BEE6F68F737141ACA92A813495D1ECEE2C1E87D55
4688053BD0C1CEAAD385B00C5EA69170D8C568B9778CBEF0D873811553052752
C171139DF1BCEC7DCDD81C26B5EC44C53F5D4EDD5D69EEB07F4F47860B2FE9E3
65A27A652F6FC9C0B01AE8991338E5C81E76145ED5B5DCD29A346CDF2F1EAAEC
909487B18B22E85682B01C2B174296161503DA830C58E6C08C67DE849E18473A
06EEB870FC53E3FA2545677A2775308F721781A1E0F39E7FF8C96E8699428FEA
20F59540A9F04D7B3A3D24397CAA1BB7F29E99204702C273A2513060E376AF84
E0CD2AA8A1CBCDD072359262392B6D0918BA35181E45D5017D956F29E3A900E7
1D91887A61CF73D11833C1E0A0836975CBAB7F9D65ADFDA8FD8573B1B4A5CBDD
08CD8ED7F1551CAC99DA2CBC614CAADF8AF3EEFDA75A9ED54E70F32FF047097E
042BA2EC1546E1486024CEA69F907C93BB65839AF9F1260D278053E8B99C850C
4A7D741CC16861E237872E77748C865593B1BE56BB5DC54BC619DCAAA3DFD904
A8AAE961D6C36082D71AF859392B4B1F92BE107AB25E7B3E0314A3E6846F44FC
45B82A24B4AC779A1CCA342617ABB13A9B5E623045329D24E5413AAF8B8D7972
05E2839EE5C6CC895C87C09E765DF15FC2A1F7E79FD4CBE333FBCFADE275EDBF
E0C42751BA6CC5A55DE509E49C0F79AAA6140A38092D309C213D70F8D4767281
19E55B3E0DE58CAC967F7B7626E9C5B2E794F8859A7077564F4002D3AE0268BB
FB818A5D765F2F94AA5F495E82BDC153E1A91CCD55AA40B796AFCBC9FAD3E25E
002F3148AAE0C067C9878DBE7D3D083E2F676D56F8C53790FC92D2D39862E308
1AF48A2A35FF1F8CFF3C39D4568FAB51CCD2503D2F28DD67BAED71F2AFA8DF7B
B6156B91206ED8814557672A382136D301940501EAE7450F90E497A3E146C230
41C28C4991390DFB4C36C3CAA12B1CF5E83C5979E704294E2DA6BD959A6822C8
E94A33FA90279D0B24D3BCB773D068EC79AF7D8936FC50326528112F797FBAFC
AED8EC415CCC8D1A07AB5B9DB1BF441245C196E8941191AE3ECA2CDA6A11035C
2C79442052A2BA69659513F8F6267EE505A06C3135387F3D2A15C2DF4AEA2A2B
4B88AF0EC8AC16DFA6D71F922F1910F98071030F9EDF21F474809E24E27B05D9
67B7B8F3A095E5192EF5C991D0E9A7870DC1B0CEB57EAC4D8D754D4079EAFE82
98CE6525F5AFB65A37506BC2711CE6962396FD6D3B39BB71CFE08B3574C621D9
5270C1A757BCCE60B16D717DBD75D75E3AF67E4B7E63242F05E140BBB35A5686
67D4B95B978379FB6E8E052F80E973E2739F2AA1408073FBFA29230E7F239048
38D730DBBBCF0388F71DDD5A78BB48F63072216FFB5D65BE5D12D94A3976049E
EEB89047169D57CD1841FA3B4B2355D4FAD134E4D7DF23E6365733C96D7DA97F
6ED84D1F231FE6B11F6060DAA49D76469974E6A7E1DD458B79D4F6F6CFE3429C
D0059A9FA987376ECB6C77AEF465A629F42B02F1C5A129EEDDE8FDFDDC952D0E
56C971A6BCD0F27FBE6561871CF0DE8D22C91C14210A12F526494C4C113666EF
7B7465AF4DD5363D788F734374017F833233EA063CA246FE2DC3A9870FB1C06B
AB1C94B692E28FC4A7DBD18A8B9E893A16D4922D0FFFE56A502FA998F5BEFF8F
4EE3E83DB7F57ABA396399C4EE2418D3C881276550F479CF9E56A1430EAC3860
A938B54DA94CA557CB35F67DFCE3DA1801C1BC76D146316BF9BA0AA77BA40DA8
E0AD1088CD1DC4F02FCCB67063E2600B868A5334493E28D480A07DFDE76E95B7
DB8AF11CCF33213A89BC74F5CE5BEDB48CBF98917D87FCC31484940B9B69A04F
F3CC5990A998A7337324D60727CB0CCB1AEC552DF07AE8D554CEB0A28D385112
9093D4363E5D0A84F94AE9155A44827022B8CF1F69EF2AEF19277D0BD0506B44
69B3F1835567AA05FA6E11B6CB7FC7CF044893FE99730BAD8499A55DD7A379D7
3F516394EEF99FE3E37097799835B40832FE3ABE66AEBEA33B8D3031204BC363
7F59E24F15194DE1E3A7D35816E5862BC9AA7E81E8A25A16DCFD325D6FAAC3C1
E7703FAE3548BCF8A2D3553FDA280740AEB58FB173632F71B384AC5EA9506591
8CF0C20784F7F89A293468E6D71400A58EC948C14D16500268CC7F76E7A92A80
4349074AF8FA0D43DF77AF6662058C3D006BB070F413E9465984E58894157DF9
99DD22E92290E6AC7243F5678A7F0A59491D87094363A61124EFAF3305F47C76
EAFA146B03A33BE2E8A8873672C787467C96A1A6056D66E1F57750DE134EC080
52B06FF1B7A20F4E94528DDC7BB7790A91A62FF8F3AAD1B179928AE3408EBB68
E8B52E32F7915B44887471A0CED5D7215964EA52D5D0C6159F3DC45FC77BFD27
5F6F7E868B71005CB9C7BABD17277C289C864A3767DC78FD49FD296135CE7EF3
0CB0A49116612AB59C12EFDC4D7182F953CD07A63AF08DB26A47D879D68F5A89
A1D91B228147FDE75A9FFE7EE7B8FE92CF64E7E6A79BDBCB5621CC1D691E2D29
331D9968FC0D479B205B9033C6D9D179F044AA707AD2510CDC4BE6DB99E3C7AB
4AA5415FA2D308CFC6B87488BBDDEB53A30D86B623ACF815D57DC8776D9E501B
F2B86A74C7A1CC3032E43868339C8650C5D143A28BAFDACF01CDF9B9975C093D
21BD1A37394770EEE4394A3AC5C2BFC7CD958B1546FB9FBEB2FE497CD26728C1
CCFE59BCBC1B1A68417622B56F79FEF737BD4F1F836AF96C22B2FFAB009D9E8F
3C56E938441FD95E2CB2C1DBFEAC0256D2EA5024F5D3ADC5EE3D294E91B63786
8345AE49585B9D86235A2FE1817CC70EC57F21B771E1496431BD1F1F8193782B
9F6500CD2CC75FED1DFC6E866F1C27B04A076BF58F0C4098476F62F4D9E2CB4A
7333EF3FC77FBAC50BFBE6824AB447D9F39DBFE5034F8849C61D1BE0F3C2854E
FAC11A396D4C7506C27979E8AF00B974939869E6DA7BF32FD8BDE159023BFA7A
4F3D14A72A94F57A327C4157D9B618B3695A3D7F5A9FCC670D60B0D8DABE96CA
CD8CFDE5A7F7DC55C0A0F972EDA853359633A3F86B051CA2ACA7FF6B22CEF9B5
27C563094E1F9233ABC452421EC876756D491D9DCBEF1ACF723E2C63913DE4A2
56BB38CEEBF5D0184CAE03E436EFCFCB51F74EEF3C37447B89CEBD06EF5406DF
46611FD78AB66E423A5422D6DFBC90CBA8188819F514C0462417DCBD104D888B
ACA0E8140D5D71375D722DF6ADBEA3E9F50D35EC6D13547FF2C9F44C823193FA
3C76BF1963918D1D80C608AC81CAA89A1BE0E982897579EDD5B0B8EB8769DF99
B45D8AF3A2138E2E31078CE9686EB5EFC8B134E7077F199062CDF98A4E4E9AB5
B8EC3E111D865BBD9A102535AA9BEB3E5CAC9CBF941185B62F94537E00587B2D
049018DFA09D37500A6F32DEF6BE1251CB1012CA6539175D61CB96F5FE244767
37F1EB89E283ADB3BF432EF46FEB3DA0BE1AE5D4C34139973BA00CB10996932A
67461BA72292473CCEADE23ADECDE18F2A39E570D4E60DB985C34FE531B3D50F
244F3E2575BE392EF94E3EA3004D6D37C02FCF7FA1E50B4027DB3490E9349A37
796226BD1A24EFDE8BA17A027EEE40E5DD1E46D74D4D811B6463598D8E0C675D
596C6FD3C9EBDBDC2EF09EDE109A066161641030BCD2549B92C4DDB92FEE2584
77A403904CA67C884672E17D2242E18D23EEDD237344E59450D7A0A62D6D741B
717175BB4D23F82F299163133FD1477195AC953C1A046A23D414A7F919478D70
50113804083192B9041EEB828E28FE798C7F00AE1911146E3FAEDDB9859D3776
8D6650F77781011A7F8DD8C00D0E06BDDC6863AA50AAB280D18F70784AFD9D53
CBAAB8BA4A23745F1A186B257078A4435DA7FF940304C3D4E85AF9FFF730731E
0114495D0BB18BB7F4AED25C30096F41779FE1F0ACE83B90FE156D55A3E56C4B
5AB27FE97A2B9B78840409ACA2B1C6F6CA9D5A314F5DBD8FC681990323163BDF
F5CEE8F950D18911D6B6DF63465F70FB2C9F6FC1E7B7A2A3102F6760237C1BA7
CDDAE5E1B2CA6012F0536D8D5AAFCCB3016C566B04255091978DF18F80DCDDCB
FB1BAAF4879364011E454A7B43F3D5998445A6CB62DD34E1A0E1C74FCB267FB1
E0E6E7167E197F53A518E1D0F6DAA2E6DBBD0167EFA0564E9D7A46C9574B6D9B
ED63F0A8928C0C06829558B7165511D1E9B1A93D861BE032979A1EEEC55FCED6
D7DE799F407755C5068C032EA1190D893F286522FE8ECDECECEA7062B322BB87
7CDD6B972BDF32D97CEAEB48E1D6A8662449135CBC6C7576A576DA0CF2E4DC5D
AC7C6AC4D29579B6B21F8791701050A1DB9BC94C8D6F8BFD1AACBF47721566A7
1B0878E9F822BAA00E20AADBAA9C8A4EDB0707BE8E38241B4581749B536E7E34
A8AC19BFD6E6B1D35A8A7219D37F37A3569C59D057CD595CD41D6180AF94C6F9
A6360E09596225C7DE89FC91A31D29DF003BCDE937FC52E2D67C30FBEC1FEA5F
D19A0C29A2AA4A7302165875F21C475947FCCC51C5AD95E65E9DB85C09575EB3
88D6223BFA5EC1E77D32A38DAB8322098E0ABA72D6C88AAD6DA7B1773F5A8FB9
23189AA9318B72838D72FD3DB01159217CB6BA4B3F58880A43FD7A9F5D3AD056
651735173D22A9645EDE0693356B5648A4ABAB892A6E645EEC2019A802A795C5
519DF22FCFA06B10E735F5D8A6F7825E109845F98DCB9DDA5B719EC05890EA64
DE55F9B9ABDD50966DE4CD0388C695E910BDCDE76087560581E095228F59C50C
5F7E311A6F65BC08906C1E2E80017CAC1CC00F6CB89B7B9467C1CF82077AC9C4
14466099CCED937442F04211607ACF2858239049077DDA17184019730E879546
DC352ED3D2727342A6CB7653F5D8ADB675128BC282144D38D1C30E38A49806D7
76571848560BE3E6370F8218C50C18F43A63F7DF10FD16FF24FEEC1BD4CD78A2
C24E11CA961FAF0E3963EFDE9E5B1040F921CCAF47EA535BEBEEDC09E307AB97
5ED7E11BD704D6E0C41D40D27BF689ED30CD47FD348711F29C90CCB46C0A8A25
A942B6141BCC85B85D8C4F8A74CDA538EB1EBC17AB363857C1C0E1D5E76534B2
1D317927BB9109CEEFD2232849FAB1495E0FE4951ED84983411522A98CA805CF
2EBE2E4F3286B43A188CFEA5FDEE7BEA9D73FB450EE6FF11233511499D00F057
296986480FFF4CA93D107C57FE605E89A232B2533A21E33AE414174A8695B048
596DBC96D8A861F569646FFBC79C836591BAB68B3C6F723F6DCA35B882B3DBA9
A73A3E6DF53A0A776AF4BD1049A58F61B506F7BFFF8E84EE70CE9554878C87A9
91E6BD4FF89E060F1B93C0BA3599F0F89556C07E1C853202250796C2797A5F82
68BD5F27CA73233188A55927B2E85320D29BB99B3564DABBFB489A5D5A1120B0
08624E7852285010C20CFB5116452E54E16C33332FB1D96FC7F094FA9F93B6FA
D3B5A2CDB7B335923ADF5122E22208EDB50CF762C99C97D573E0A9FE81079C1E
F281073E44BE7DDDED8F815ED0CE9C3E73DCE7B3F0C24A518AA4D57F35D45452
1E715BEF13B48742AAE46166336348B09A6B156DAD610CDD3064C65218664476
D32E6D8DE72FCF756184319E202B57F237F21C09F61DF84D5B72149AC8A08C08
FFF222CC3126DA25B52F190F233048751E98D67A1F3D5558C0E81F09C9935843
DB6DC3B373E90FBC9681BF962E36B25EBA2177243700CF95E1871115D5738A7E
0DD8E2CAC9FF1CB4D124C5ADB05138C8F85A0B741C24571E74ABF75AAAA16C20
04E86B1797B6F81CB076D4861E83FB9C1B7B717E1967B7AE3F41B0D8380C636B
41E6481393629660EDFA37A543047CB353E24D500718E6E5DF23D803EEBA2C52
8C043E4F64E0A98976A8A883C5D2B3B7895B49A3AAFF92842917DD5EBDF6055A
56F8EB7696A98F7B536FFAADBC26FB3B01762043A98C0E65F566A1C695F8D501
537ABE3F15F6ACC61294DE7757D5E93EAAB970DBFD0B0A4C171D8C0536810ED1
6B94477FDF68D35E3A78C271F0350005FB02E3D0E3C1A31B958EAF3A534D610A
7056AADE2E1CF84843866308DE72D60677BE043062C88CD8FF8C30B9389F9CC2
8C546EB0C7436641D9980527A9D622CEEBD235DAAEE75F7CB4982A875ECB9956
5EB047376710B349AC35B4A1CE31F6B9529F07A74D15F0259D7E11B99F7A3DF7
0B6E7186164EB76016AA25B2BB44131853643A2EF56BB692F6094A8A71F70C8D
A8C9C84B810A2656D261F7600746F71F33FF1B1FBC531552236FB40B53E3A579
E44652607DD2C0D0BD03F279D4C279D4D20916C5C2C84C85B9EC0148E964E857
177D94AFD2555AD347514666FBDED922D68614EF808D8A0B8323B5363F879B50
A9889B31AA8AB1127F6A85F36884B3640A23DFA6BE42AA18EDE7577C099184ED
DDEF9A663A888F8A04CE947372ECB27BC27CDC3C7D5365CEF7F2E64635711505
8BCCB9C1B0E02641A971616F482015FAF8928B814DF5223B94F37A2595546FCD
5837A7DD6619E1CE79E47B28AE087F87EE73E6FBBCD9BE84D91DA3BD488AE397
1DA5FA37D5FA489977374C6F8918E06F7DA046B496D11987929C4B694FC683CC
6C985DD33F7AEA70251B09EDC26146F3020E80603562EE1C10F0260A1C5FC6AC
8B31706A78D4EAA76CB4759DD1554503645B6A5E96A3B33E1E8E751BF65855DF
AD24265F372275BF50B965513FE075521A8C020D23C61C4C4A673EE67074D53E
AD75FC26B56A1522CA25C441D2FFD4DAEE43CFD08C97EFCB4A472B7E804EC49C
CEF57A08E04B42D5E03156D4533EA77D663EC228F4CFC3DA719B8EB6DE1D1388
CCC86A82188CE782C8CC8E862A716C42F071140254B72AC91B9194A2F3B2D696
9A31DF3B77D12376C763851FE56F62F2D460CF9424834C48C199E97A8C52D80B
FBA9D2D722ED67EFDB1660A6DF69C1A0C295D1510ADD011D365BE2C51E77CDC2
0EF2F9A800CE8D379374859197831811AAD0E11ABD054DF78F7233BD99132534
7C4EDB07F0908B6DC9CD42010D766FC97F9FDA4931665D840B3BD946646F5808
4A7E36FA80E2091B2D536090D0DE835DC0BBBCF85E21981F98FC95283C8F7F08
8B4D8ACC54D3E4F5E146BB4F21E5DE809984881E514B7DFBBEF712E604BBFB2A
1C147FB5FC176806CFA8E3A290761D16E919EE0EEA3ABF1E910DD1EB0C930A43
CF37F45591DFC3BD29F1125A4535A09BFD125E71357666762FEA7BE5CD2100F5
FB57E18F08C0C5BC567602179E312BF499DA82EBC588A756A598AB1498D1ADDF
7AE531E1BF18499DF8C812F15B6098F3FFEB2EE33DC1AC28A9496278C3DDC49B
DF25A621E3C9471246E8884A7834380A0FA6D94A42164FE5D6C797559384A4E1
03E71C8C0A7926AA5643A7F091A006D6777BEF6DFB14B6ACDFD7EC4B6B172972
F82F4755586C1E40D07AFC78D88875305BAB858C3DD2538395C0E2E2EAB9CE38
3B7C599AD7E9ADBB1A31FD0E4001AE32BFF67375782B86D16334DA6B9D480E9E
6D2E0FF95A3E2A9CF3AF9B7CF71111117BBF9757FD513ACB121C5C767659481E
AA1F0371C24C7179D5AA778BEABE5E0B22DDD75102D7BEB07D67E56AE4C363C3
41F1F04C99F38773F7D663BFEACE2BD3CB1EC9398900960AA87361BBB684F596
9E36F0DA34B787A38CD24B84035C644AB515D94F76AB33A85F5D1751B57F85E0
CE7774D56D14A7135D63DB186BED9322E3391D55D16B5D526606632B9E536ECE
C678F4A97DC34E5E3FFA5EB82DFB0B0C5DE70D2298B81516B213C039FEB875DA
37CEF0CC0B3099443CCF46CB4DC451F9C471B843A81F77615AD3E07C8923FB4A
F9CCF8557E6B07AB30A9522AAA597341C495718C0539351B4312686F8F9F8C86
D8D507AC1E1BBCE2596BD807BBAC1D017979602FDC95CE5A22E510741DB9C1D0
EF96B5C7F91B23E483E5C08CA4D93BC84CF44FD1B87D5250B7DAF726DBE0EE4C
50A4E2691DEBFDEE4657B4F93E769ACE7EC66964C1ECBC4CA5A190DA1B4B8DA2
E77D209CF1A646DAF4C0E447F4D5313E401A0A371B1AA03AFAB80E320BC72DE2
67794D6A060830BE729498C7F360329F2E486E4909D55FD050288238F862CCB8
34C09F0382E9B09FC599792AD66B57A0880CEA07FBEBB74415E0E8AE43B438BF
5349E9FE986CD9C46005AFA5269D435FF535F691C6FFDB6B9EC9174F7C133E25
9CAB6FA75EC588605732F3CE021A2D8761AD96A54D9136AD587546AC8B36479D
F26E8CF47E2862978941F646916C431E0E3085112408AFD5887F20BCFD5B5FF7
FA2EC08BA2AB90D566392B6D09EAB90B034E40FC35389C6B82BCB452E2F93BC5
ECE2C1B198297F258A282F9016DCA0602D46705A9C77B527B7D9F3C492766B4D
D14018DC7CEC39CFC4AC04529829F39B0E7DF2794BEFDC96EA802084EB3F3FCD
499456FBEC3198CA758ECF78A6C53C4F78529A896CEA8CAE5A330D8922AD6B49
ABCF4637D1BCCF1C865A3CE1C71AD6B002E4F40093577D4400FA73D978E726C6
274009382A01F835FD4BD711DAC557EF5E7B8438225EE6AEE4CC2D8A3FA89D59
3275A6C8848C67F2F620C9428EC243C026B52F1F035FD5AB341382BA19FFF3F8
00BF715E8E2ADE4ED9682F6127939404CE3F2C005789A784ADDBA4FE86B13236
C6792C954A337A4C0249E2008F0A98AC16005CC746D2009DA0A94847781D1505
F0ED7FBE021F955F488A9621814FE131604F34AC30366966D3965A1C8A64C010
7DB00ED420D35AA9D42E0CDE22C6BF6EC519ADBED96E0CEC28869C11CA3806B3
B4F0F4236BEB835BD15BCE686CE64D3D8504DF07DFCD9B962A65FDEEEBD6B187
E4AAB9A553355BF3B07AA2B6FCAD43978BC7FDFF4101E8AAC7931329F71F2FC1
141CA11E072FF92CEF1B7E9D687A508B50982B38E305A29DCB1EF1A4425F9F94
6E7F28DF52103EF27D6B15CBF564DA9F2FC816BB3018EDEB43EB3105E59ED9BE
002DFB0435C6DE67B8A5E1C114B6FC7CDCB676D14EE9FB383C131BE8F85C9557
1926E52A293724FCC05E319A50916425C308D029B040CC83B647E54B05D3357D
4A893A5AE8DFE7B62E918E80A35A5E970DAA2463EC78329E433044CDE2689ECB
DF01ED106305D341BB224A561C66183F32E7266A9B8703C3A7E5179176C32E07
C2BAABA83DAB9E2333FBB3939D45A9FEFB856E04EC7677AC7FC5B73BB2F28BC2
E9D857E66B36BDE8A66BD0B08A98D27394AF7F5F27FB6EF7A00B6781953460D1
04247CBDC724B568EAF96E7342CE119DB940D4E34C2EE195306CB9F10D1F64B4
D1A4261EAFAAF74709CB82C7CC7360B404A9C3B609D77B3FE6CFCC959848E597
A33D8529BC5134C2BACD51C4C941943909E84B588572133968D8C9A576BE50D3
3C45BDF95720B0C53E84A0C26144A6D9533331AB9568040FB5D05EA2A04AA783
B67E1FE114FA750B6E7588FAE43A2377AFEB429CF2762EC8B599C01126D45C4A
F7930FEC7365663A4AB10350E08308124AEF1C56CD1A02B6607C2821C839A5C4
E59D5333B86668856C12DCEA33B011D1C0AAE6369A83881AC0C895CEC9D61B3D
72D9E9988925B43CD44C0677201DBF5848EAD023DCCB9EA474CD35C4A4A4BFB5
B77E75EE48423F72660ABA533A738D7D724070B630F4B0772FB4880C082F0A8A
CEDE7108DA070AC5F9A9A995514284A54C063A41FD97AC4630D914249FC82B38
9F7A6851895F33A3C5C35CCA51B26404556B04D77FB0F8D498946A73924FC20C
15623CCEFB37D3FABB37E3BD6F09CAF327C00DFA58FD013D9EAD2D88B01654F4
C983F818438C74880A7413E8635908D0EAD76F7450D659DE39C56B8442C61621
CC37359E6397058374DA24E163B47A7A3BFF48BE11CA7A980601606C988F7A50
4B643E4CBC6A28EDB5E1312979EC47AE8198D8529212CD4798B336191B0CC7EB
76E26DB544181E89C0FF8B75EEB1DF59CDAC54CAD5EFF289A9B7D21C3711E33B
4017A57297AF5A3E1C9CB0AA225A2DD5E2171D0BB6A731A371A521FC60D067B7
8FC23A6DF3D0E77D9071466AD8CCA4BA2F10874A306A94C0AF48A292015C4459
BE49719EB45FC02DD63F80DF647C69F78856ADF59F5C3C81DF24D13A744CAD68
824C8E194AA8CC9A728CEBCF6DCC924A28A5785865CE1F374905D4192E141233
CD880B81584154B6B7E9898843B47CE4A1E974A78183FDA302999F1A393EBFC7
85759F32CD3425A73710FEE11B6B3B23CD2AD46275EF3236903F3F1B405F2610
AC9DDA957EB650DAEE5FA1ABC3C576E91158482A0CC98BE75D1F74FAEBDEA9A4
C42E70F0A05D53FCEC0C2E098E27F77DE906E61644E74824BE2673845AC278D5
13D4FD901529147F19D62020CEF503CA4D3AA63B737B0D57E5EE9C239C3AD9C9
A06759B5C9B2065BF36531104225EFA82C0E9C8FABA0AA752659C90B87B2CE63
12FA3F814B25F1F9154AF2F723024F4088B8F410180247DDCF8CE7E9E4B04619
98633D343AFE7B1556CD70D31F2B166ED82CC08B4371E958A61F72B1D04367A1
F79F732DFBEE44919FE6E8FA877A8A828772621D0B009B86451C8C8C8BF8445A
CA65DF6F572F8726C5C1F058FF901480D494B8CB00275A5A5F9BD92EA3160257
95683F27D268C6D55D8FC586FB0C8CAC688BA09F51161FEC892378DD9EF71EFD
8625FC998752DF8E7DDA3B569908508B1666E24FEF2B67CAC03A686204151A8A
791FE74A36DB5925C9B23DA1541AECB98E9539BA87EFB4149F1C4DED076DBE47
E899537045C2FAEFF9B4FA933AC45A6FA8D641D195E588693C547BA8237C0108
A7467598BC640B4ECC3FCCA3E1DF6E32993AC4E9DC13B9B2FDF0C501C590721E
77A30291433645BD7DE1ED8E082C5B866B16689D6B716D3250044452650AC9F5
95DDE037DCF90962F96C215CE9B0DB507A501BA75314AEA30AE6B7970427BE89
D484F4D64C61F45276FF350A6FCD1A9EDCD1723F7818062C998E1B7AD4B3D922
4F0ADF97394E8BE5FA65AAE0B1689FBF1B8F70B47C770C62137C9745B86DE2C2
8C4AD035FFABC15DEB96D92216AFEF881CA217FA184AC72804BB595F95159048
DD7AB511DEB7826F4C14C722B233136F9989303481B529E3E1981DAE5AF8D8FE
86B02D37BD2AD9D78C678350676D7460B4407DC225FB04124570D588934970A1
0BA4F0500313465AFCAA8EACA370B81577CCBC216BF9718A5AED5F1BFA1DF2AA
EFF3B4CB8EFFAAE8658CE24F7DEE42252716F9D97FC5C3423AC09E4442D081A3
741BE9EB5EF8B280D751708592EDA8C1D37719922B4B65FD1EACFD67F58BD2BC
346E8FE6A60957C760DD0B6C7E6DD0E2252C45C351E0C08FA189A4BAACB0B978
A58EDC1249667A5B69615002951E80F571B7450BEC6931D1321C86D5019CC280
6011CFFE983E8BE0C77FD55D817EEFCF2CE05493847F68802FFD7106F1045878
C8A8C0F905CDF951833184208463E73BAB631ACE06A9A9F9720C65F34324C755
992F10AA5BC2885F0FAE0663EECAD6D59F89698ABC09A67527F9591E824A25EF
C13D8F0C60F55FE74E6492D8E6E8128F318CF65DEB3C108AD5B484A6C1901A1C
0987F4BAD842922794D6B6F9B110C189F69D3F39C6442A9DC9D571BBF37538F9
C1819320B766793F249827D7B0C791F05150D4507751BBA3989C995738A25BF9
AC789DDAE73D114E46C1ECE0944D0E29499653CD42851808B6E7C6398E624C24
37B1EB0A3D8FFA12368BDFDC6623F15CC5515113D3996EF4F6204F70FE49BF22
F7B88705668F4729C10ABB26ED3FAB735FC84B268AFD321CB6A28780110A4A00
ED4836EB5765582DDE52FEAACC4B6EC3AC2B8F1B15359D31E74AF3E9C97A9669
9E16C206FC306E61656BE59BA71B099102015426F68EA7F9EB562C47E88BD4C4
5996AC2938222B75ACB4A5B7356D647368EB34BE769C525F3B88114D50F2640E
C8D94D1BA7D1860345F16D91D787784C5011B906220D6D84E12F59AD65F6F4FA
DD18E9EC124583D90B9DA03EA416F8952DDD68635FBC339AEA0C8A3205F254B5
855DAAEB9A473EC301C7C1EBB02C33433A96DA4D5F3D2FD8F9C55E697BCC9D14
602322ADC9A7D2ADD5AD8283DC9CD1C81B97F1EA2330D472B77AA4A57684B3CD
23F5794934FEF55B42DB0A2538EA7D20E51721C9B3F2215FB2695B18D4ACBC83
442AA19936AE94935368E4CE7B0444E459CEA88CCE5A4B993E67914F206445DD
18BF3C69D2737815C289FA0C04DFE7B258B4C8EADA678CE56E1247D7E9B5F0A8
81EC5D3588BB8FC5EFF34ED35FC8D40F1074C0FD39A687303EE12B2F197003EE
8F207F548C92DCC4D49B12E2AF41413ECB7E4D69D2D9C00EC73685E192BD7DC7
1E9C97368372F9F28C1F1C53B6894923EEEB0C930A43CF37F45591DFC3BB48A1
CAD549D2B0B2AD15187F8EBF757A48DF1F3A8E7B5027769EB5912BC01221F7E7
94E4D8379B64E2381E69C37D3E933A0345DDFC97B11A571FC8809B06E0826395
0FE5188EB702E031EBB07470E1A12387BA7E492D38D6BEB0EF3DF5243EA9483F
86D1F473BD8C9A2496E0BBB186970C2C7DBEE6061293FBC6D783019AFCC12020
DC7A6C18D0F7EF117927DFE26BC985D885118AEA16615ECC4BD74C21282D3554
69F7126C6397932F8E3A1E8CABD37E561DCD7CEEF8BB47854D0166A4E14D4F8F
B1E4935FB67016A5054CE76118D25A2700E4E9D7DFBCC34D14196CCDF9085C1E
F041B4ACDF21353F370B3584438F3793F7B41B1580F353F44F84284B87CFF624
3FFEEEF59E6818E5507A855F9185E392C6B3F0FE67C13EEDBE27EABE615293F5
3AE9CC5D9F226359B0D0DA1D46AE862AEBAB2C16F67E46C2EC172858409D442D
2ACA551EEF9C2D63AB04558C40C14681BAD5EBBA0194193F12F54843F070366A
D98D59370D3D8D768A63E820260D5D650011286E50E2A2F2BD0D6DC402C3D7E4
016ECACDDD3603F351E713BC535C09CE75EAE43BE62DB22275311B906F678C78
056BFCDAB3C437179A79ACBC7FCDE62C1296D929E3E3E523D882969A8AE67733
B46980C83477E84B2A2F3401E0EBE83DA7029F6DCBA205AC0B52FB0668241A81
DAEA5CBF522B744E48AFD156AE06177F270A4BACBC25DFEFAE4490725ED0968E
1A188F5D1DBB7BB3DF725DA364D36120E7F6A13E116159AE831E4152EC9E898B
9056F1C580BF0D51FB39DA2B40EC32354EDAF89C84C9A546CA5F71F912D3A7BE
6A8F343374A117F305E3191948D03668F5CE8CBB0C3FDEA6649D9997C93A8D63
77B0558E2A64CD3B2D9D83FD505DF3B4B12754EC2AD90CB1358C059BDC82252D
018C3E5C6C029ADEA53634E03C42727A2AE4E28D2010CC1DA7F632D9FEBED96C
69A06007D987D192DBA616387C68BCE6F7F90937F82303C6686F491B1BD79461
7035E0ECE6A43A7DB494D4DAA78F67F1CA65899615D858CA23CBA14094D4C1D0
6311DF5FD96880ECE9492DC6A16CB1E3B1BCAA86C28A11486C27E0D161F29A43
63A0E9F7F4231EB78C7DC42D46F4D4C3458D531CF07FE6D0C9ABC3F4960DAAD9
520F86CABFE102F0047B3476CFB2788A406D7DBE4D8232159C00BF64F5721ACB
D0AB6E546CD9C09509663797EA6539AD24CFC84B810A2656D261F7600746F71F
360B0D5F66BFFA791E17E1FAEA0CF0B00E37C82EBDA4AE171095332F840366BD
F9D40562D677175054175A89C04ADA9BE53A8BF27C13F66286B4D8CCD808C3CB
9B92D2B264BE2EF084B3E5824DD9EF586021779CA0734A68D8BC78E1AB93692D
A646681B6BDCE89977D75CFF62AD2B62B5ECD9E8A74DB6D9FBF126C5646D6ADE
7DE0A3931D012BC2CCAC4E2C5FD05CCF2235C069B57A6554BD7424E8696E29E8
80174AA7BECE3475109E2606F1A49100BEBFAAC5D56F0C727451815310C07964
9532DEDF1E61342FB7D57AEE1298E88F85312C1F9DE8E8A6E81C073AD4F056C0
7F76E7A92A804349074AF8FA0D43D8ADDD6704109924E3CE8575235F808BFBFF
99AD6A8E4D25E7A0656A7ADCC2A73404EA21FCC605617631B168F7FB0FD472BF
ACF67D7D5899CDA22C5FAB020F9E6C4AA31A77F43A0E5D4E70C3A272CD5DFF38
A45647D01055B78DA019EC901F8CB882D13780ADA4CA5FB39C0DA0F9952B72C9
04E621B588780141D29407B28181E42E059FB6769E965F6831A43DA135E97C2E
465AD8C50485E42B8AE63A7A47B495F683B89BCF7BAF9833CC84ECDEC66BB795
A8A4C51152DB586338B7B4A125F9C9FBDC4019076DD59AA5F341538242A02894
6B1CA619ACFFF8C7D91BE319EA60A6656A890DC8E3D1231374F8B233A3D90987
3319150C6CFA0C4EE73CAE558AC0565B65E7D3CCE343B9B312A4EC512D72FE3D
59DFA48FB5F9333D89A50536251C4C11C4C425DDBBD2A0937497212FBA8D9CF4
27921AAA804FCE7C1806457E9F3C13CB01805B0B057930E7D0AE58544692B5ED
12F71BD9F04A554547A97A70A700AAFF7C1EF565F0BF11A562B579A3F59615BB
28B04F50B776CDAF449858407BBD7465892B70588D708F83F79044900A813194
DD1E59DA20A8E80528C9C1A257017EA997B425EC884CFCA8B0B02D0689198F5E
3A1EBAFEE4BDC1B321B7B08BB56BFCBD2FC2B26EC33114CCADB5CE028D737650
D73C050BFABA8C25ECCF834DFA5FEB4CDE8DAD8A9A196C4E2C8E6EDF2A3D5BE8
963CED4566E5C3AA61A240D724C60EC683C76A925341734F671F3FDAFDB13EFD
2846483BB59CB2EC012EA2ABCB6CCFBA285CCF4D5858D6836EB69CAD543DA05E
B770D39DF17FC3F6988F4361D1FFCF627EE6817D37FCBCA876AB2C506097C769
0E409D3F970B4F9B36F73F82034D0B4AD4AC6867302A8D6A598D948EFAA0F5AA
D7E227668A754B66B492C384F8CC5359BEB40AF34FB42C9B63F41CF72F026657
8A929CD02CE75252C5C8E8A59792B406531B0A607197A705D7A6E842DAA661FD
9B397A3F26BEA917540624BF9CC6D4DB5D115606D7237D768A9E9B3C2F2813A3
E168C88A9959FCFE317916EF6D2AFCC4A55CF81BCB8031D291D5F2503FDB89C4
892DD310965D3F3A00A36870A3291DCCDA8FEB4653AAC9C7FB106DF362CD2BC8
0560121680AB05BAE17D78E2F61464523C36CE442ABAA8D35177DF3F66505A18
1F1FEBDF3F1F385260358504330449B411D62BE265DEF0DC4086867A2799F1C3
4DE4849C91FF3FD1323A50B646D5FEFDD4D543FA474372FE882318A0E0AB0815
37DBE1687FDBE7FAD7B3A2DFB83491F0FEF72187B65E6393CB85E9B06AFA541B
16E78E2D275E23D201102998D39066D46524EF155611A4283FBD1EB9BCCA5FF9
D0E0CD879B9C685BC64DF62217946ACE5A1C9CC82CA5E6ABA3BD6F093A46408F
CD38B85D1D7CCAB29F2E3482F6E2A80F4802283DF85DC40CDD2A5BBFD8DC9B6C
BC52C5CDE02BB9ABB47FDE6282439AC53890FF32D0283C2B9B1397854BEBD77A
93C30BEEBFF2BCAFB8ECFC153790FC36D0AD1B581C96F1322CD5538710707D45
52F09D49025027A3D2A0E209928F545F89905F5D1D362244305DA0D13042DBFB
6B70AA8BBF8648AB63CF7DF47C88CED0B2A565867D844A052AF3F25690A5D28C
C0326E6064832CF39AE5C6C6F2DC4924F4833DAD671EE4AC427DF83E4D5B9650
D7C2DC396A774556991932686B616A403C757EDB2FD9B06BE18F257A4BF09E9E
CC356F404197721D9D05FE0527B106F9340D25ED5EF271DE8B865B357A8D8EB9
8B4536EA527F5BB056EBDB6B25776E9D370B4C636ADF062E913F3E244950A08C
730CF801C5BA46C06741B1FE17C0379D7B3161E3F62D58EA0C827627C703C6DF
E72D7759C8995C7031555A41A190B71BB8375FADB988E6FE08AD0BD8A42B4AB7
F6440FAB57175F39BE5C52E83D1934253B13D79864AA4DA8F143C672552C6DCC
CAAA7FF5B103B7D8919E60BD887421ED1F88627866A781B785C4E0CB2E7A571D
9110F36A132A088F02C5F80DFD461641C4F8FF237D16BD6C75291A1255E592C1
AB0CB3B6A59CA465156722E45EB0B39A6BC253AA341A683BAD6174B99AD67653
0833A191BBE695D04F2B99D97CC5B5D367C7A3FF636577637AA585B0DC82B366
D12A7F261180815678C38B4024C04AAD3E7D1B6A9D5A0C7BEFFF63F08C212DE3
6E78B8C99D13E74F1FB40A7F6E40BBD704E1D9F468464493DF46AD3B179D1C3E
90C0B1DFCF8FC52F40EEBE22DB892A6F9063F31D7F28BCBBE1FFF89F00097EAB
B568DFECD6E0815C0E438F96417E58C4D010C391B51064EBFE0934A0B9F54B65
1BB36852FA54BEFDF6EBE5ADF4585514CCCFE6DA1137E970733CE480FB161352
BB09E0FB238D71E2BA17A1D157C1E7187A8A27F5EFCB49A22A13D6EE737A8107
63CA3F7C53FF893B49E249F8907AFD01B46324908E8D480C4FFBAA393A68683D
07E37FE091FB1460B43D21BA7A45101DF299898AA3E35246B48D95B56A049C11
FF103A055F5510CC81604178F8ADDFD73F1131AE570FD998F59DF3AEB72FEA9A
74CFF6605B45B2B1971A0744C8D8A15044FD12CCB27B5D1115AABCB635428A00
83468241DDAB2F32540C14D01AACB8BBC47834F59A12180E4E1C70090F39315E
E140F19C9C41D5762189E8BFD61A36351CFA99DB19267CE6484AF6EEC8EF2C41
A7AA53599FA7FB20654D9E9772790B5956E23426A07FEA792A34F67D863033C5
2732A1A111AE3B7C647628E8EE8C15FAAC70DC0EE640F4FEF68B2EB610E5B65F
1DEA90361C556183403D54493E29CDBE7BEEE259A930E97F6E2FF49AAB53CEAC
C461032D69A6656A890DC8E3D1231374F8B233A22A4B358259BD48F1C2F64193
8FEFD0644C050D99E0DA6D8042B7B5E3462B8C46CCC1A9F66401D772001C19E1
A63EBE7E645FC466AC3D1FFCD8FC020F6C1299D27F9136DB6D697DA046B496D1
1987929C4B694FC6870CC2152F31AE048707457FBA3A994ADDC95B610405DD2F
BF77A575F65011FEA13A7BB662B81A3628270A3D93F44D7FCD00583D0D107B91
9D4C7EB7815565335CC40D3867D0FC4D55442C55FED27EB5DC8F7DC87CDD400D
50B0BEFD744FBD8C2FDDBEED7FD8F252883B6F589D5613B3E7DA8EBF491EC591
9D8E2CE998BB5C448C309C5C00A5254259EB73172C3F4584439D8E6811BE2DAC
1CA82443E48988986068F7262128F93306A5880FB7A05B4A217402A647706437
AE0C40E324093226728594B13E09575467DF0EF192D0D202C5446CF827FC1330
535918494FD9DF6AA34CF8BB86F2DDD824F786BC712F2FC4854933459F690875
A80488238AE49B8B90C463CFD507C04DF4FFCD6E29385D5AFC06C6679A3138F7
272ED1BAAD492CCDDBEEC5807CD374E4A3EC0E0FB4E7ABCC5C11EE546BEFC53F
CED601D014B58008A2FA7DFC94E2E11D2B105926D9D0C23FA56DF9DD64E82404
245822476517A40DEE9738542BC99A6B1E412B0A47BB250F06B09F5F3F8A5D22
DD3535B6A3A946C63438B4F28B26B534C88F3D4D22E702CD92ABC3E31ECBD537
3B3945BBB598A4AA4E2F344478FA4572FCC15927101EBE5AD2A733DAEFEE910B
535FEC4BA5407BF619E50346D59C6C7914487D1736A4484C2FAE78B968D08D95
1AEAEFF289EA0BECE061BEBFDA248EDFA736B00AA6BF0B091A806C68007CD2B1
2B820C106C342F852AE4F0E096C8A45D781816C1E1FF0E034D80B2D886095127
7F5FA1A5D98557752B889A8010DE1F1D17CAF8F22E069EC53FD5E9C745E97809
1C4C8B2D54E75082CC334C2C1D3EB68F9CE53FA3300E1412D1E8AD26188AD664
FCF5A4442347E8302041DC8E6923A275A78BF3A39487DE37C9E8B4EE608E4ADF
AFC977265B81BE78EE7CC38EBBC68EDB4442B1164B87B1EA798050639194E3FD
F857E2206DFCDE0AE9FD74528720820BF263481010031B0608A63C2F9B6F0EAC
12FD843C89A4FEBDF78B312BB0BD62D83914FA2BB53C61B5A8C71723B7E2444B
58CD0CD9FD9150E63FEDB24200F02D3C9256F0E0FDF97CF83806DEC4D2A4DFE5
78890FA15800B3126828A6E73B21EF6D787D1728BB722A1A0309DC2C1CFA6831
E2B65065147DFEDC4222CA1387AC2CACF4330A3A429841E68E65B0BD6BD3C3EA
3B0358D6C0211F039ACDC637FB5B629CAD8E550245F3E2B9301AB476492AF87F
C4915ECA297EEDB31D3FB57FE0A686155C8F5A893485E06FE538DD8D6D2A03EA
B951FFD58E493F7712CFBDFEC673316E4E2450019C1CBA3221A576A3506A092B
4F43F7D8A513A8E3C3C2A71C3D47F2A494C1BC72EA59EA0C7518E59575B5A7A9
96BAFE91EBCBFF04361999254A3BC0315D96AEE5A3435D9554C128487E759B55
5ACED0B6A0A6544647364BFCA73564D5DF56D7D31FAAA18D1AF32C0D8364B431
B911BADFAE94C5789D864D85AAED91BBBD2C493EBEB81392955105AEC38EE036
035C17FFCC089183C1627DCFBD56AF94B0407D5D483AFA01F0CC6C836A67D26A
BEC7CA33ED3B427B47DC8F5645248EC598904291F42A3387C36544F2E5A63B5D
19876C8E2B1B8481D71578651FFE6A23FC8529F4147989388D8647881418B209
2EAF5F5E73E95B4E90CC5517CD9D127D676D481FF9A3FCCBF36EE883AFA30B03
ED18A99CE066A90437E978D5C9A2E3BD77C30C8C026D742722327D380EEC836C
6BB9AAA79A79E0B93DC9AD01BF126C35FB523B345EC97AB5684F393198F85062
FB1E1F8012761C3C4AEB59EC5DD4CFE027277CBD941EEEE874B88A2E4557C392
3C7F62D79CEAEB076BF271B4E43499659079B44EA98C7FDC8B0D1D819B9A1E07
D244EB469EA82B6C2B790A65C7069CDBA0B09C0CF56FB14521397D6B0F88F5D9
62F6F9582F5BCED7CEB37EBAFD8206E691F7C355A8D8155EDD8881A363686169
AC4689791F1C0860C3347FA4A215E5077C139E36B2F9674CE95120DFF083A04A
68B73340A80E6D63C5DF344760F6ED7E6FBD75977C72F700A42D82FCF9F2A714
388A9A15B7F77364C6AC168FE1312E586E7961CE932F3BD450DE78BC5B4F33E3
6E859A0D7A0DB9382268A95C143D48126E7C74D7B32CA8ABAF86263B342D0455
A8BBED700E8131D312A1E453288D0CE691B0074A0C828448BBC999C21E149C2C
C096F2E1B0E6477059BBB61BC7EECFB0BF1FD6125E576FB2D41C012CDEF7338B
5A99CB7AF2740B80930E0150053C6601FD711B0FC094123A06D04576A7638491
137DB54FB7E9CFE74A2967FAECFA026BFD3D30045EE54E9B97CDE5FD21D5A043
B8FF916F0ED2EE5FCA0E4EB639B781EF82A7697A6B458CCF339D3CC4882932BD
EA2B64678165DB1F067A37EFB050332ACE6E53FF0E886F23E92CBD1B1B943C1A
A99370C24B1E156846EAC3C22817DCDD48944D89EB2E618150AF76F9870E2025
23B33A163C87B8331BA42FF478F501EFA71600D3A397BE2BF06333F73B2FDEB0
144976A424A3D35CD7590E506B594ADF0FA37688A4FF913D3F49F68EF4316FEB
64D096AB0FBE450EFD0039FA92256474A9B6A94BC1A3F7DFFEDB3327B002D1C1
27F45889DB46374D70F5DD66C14DF54F62D082397EEE33370C42ABADEB88D3FE
E8E7388E86A129F62D7F314F142A4E69A20FE4073093158C8C0A9FBACC6D518A
7DDCAFA896AF9D4FFF8AA0AE3DF700E40C24A8C6D43370FD434E51A376D761E6
DF3CF6C7DFFE3F0B55FE5E4D0A0A6587B52BDA2CCA98E48781BB1992C1BE3960
2C603E1E1E3AC4CF1DB2F547F3178487872867CC573EBEB40D1BE99879A9FABA
F918A2F041B9DCCC67C1D7D3A74B55E2D4CDA8C2B197CD71EBAB25299F3F8B32
218111E577BF180708D22041A7AA53599FA7FB20654D9E977276E3FC584CFAAB
480586C90874DCDFC2D70EF211DCBFE173414D2B1800DD59871A3047DE6CDC78
FD49FD296135CE7EF30CB0A498F2DCB490DA0223F5ECAC58F58C6DAB6DF355D9
009BDB693F128E95F7EC7A019705EB76127DE3ADA10AB0A17851972FB0832504
193C740B21C572D7B128095B9CBBDA9442A9042BD9FB5DA05E0365227C79AE17
476A36E7076DBE47E899537045C2FAEFF9B4F70FF39DF5E66E8CA74ABCFB9F4A
745A14FCDD47A27ED377CB612A8339108F0636CB0E222275615D5535203307BF
0047AD1108A63A03565768547B24308251BC1F119BA6BEF938BAAAA332EEFD65
4E792BC98F10E25F55320F08C34C1B0973DA0C9A2A32E8F4A15C5FC3435AA0E0
DE20E6C111559EE48680147548399F9AED8498CD54602657410BE7B23DB5F542
C08B8BE51CA65422CA6E43451277ACAB88C1E8FE83654B0674457A70F32A8ACE
67BFFA2F19E41E22C2614EFC3177E8AE914D46A335778FC9BB9D8225ED784DD4
404E6BA2649C34AEFBD15BD299DFB1AC304ACED7703A43AAA189775711FD6B22
74EC68A27893114CE3A474124A5B324CD5BD1D45174ED27D8CC4785B314D3A68
BFC49576D71E69CC863659DB1044FD07C22F29FDD237AF158ADB0A32797DF361
18345B2AEA26CC7A2F4F47D6AE41C62684899C8024A1AEB620A954868E726BEC
E76163D1FEFB4F45EC55A5729E750E1918613656A3CC07A5C83FF6C7314EF032
F1FBA346FE9F894A786D9B3AFF1F4DF93CE793480C57235CEF0B92826A4AA520
DE5F09E5445375D36F7194C90509DB4862F20EE091971846BBB054A5E51C596E
5B804EFD2A8EBE557A32CE4179FA50A9FE744A10EAFD350C36581C8452417A4E
377D2ED3646C0C5EE499A8D210044D04A99ED7BB75519C04125C88841BE3D3C6
E932FAF6EFCB3A63B41BCBB1A8C9A7838F85537AC2C36F8A28F152286337E2DD
615384467136E29A6AA6C51DA0068DAAD15CEF4353FF60F94A3D877BDE1E8CFE
EC4FE08B8D9DF0BAD21186C39D2AA1FFF0CFDACB97BF0C5A6E60F7B3FE08D213
CB51969773738E29D09DAE14290C38E44CE1FAE7CF4A4FB3ED268E304FAB1E8D
D820580BC11763051E5B6684DD3C18A2F3B1263EA91E53919993641395E3931B
F90E41D43FB6CDD6EEA6799D485266E539819C5FD002911F249D5A65FF95FBB1
1963A981EEA51DBA28193E11C233BDEA1BFA0AD8CC44A01334D31C86848061C8
1A73EE0E65B3DC6630924B8F0189ECB8199B201992F10D4CDE1E7FDEFA38281B
1C193B556C3482050ABF700304769949BCDE80E5EA63414071E441BDB12A51A0
CB83F8D63D88AB13DC01CD77EDD5685B43D2665810FC3A9620B4D14DAD023E9C
82F463E979F234D37FC69298EC0983D3A80A3414BC474D0FCBC8331D0DA85CC3
F64AEFFED16323AC235DA36C1FECA95DBCBAB7B9752B0C5F0C8F259C5585BAE9
5537CCDE0F2814027662A46C31B85141481460BD669B4784B39C6ADEBA93D8B8
DE2CA4E4157C89A588672AE42439E0933DF17085403329AA588D3C6C6675546F
46A0AFEF8398F5923C969F43AF8D7FF2098FC53870EFD40B09B8920930E3167E
4C1F56AC14483CE473628B0579812610D90760E959BE18FB3D68DA814315F883
D4AC9714527EEC26381A45F7EEEE0140D7E8E0F44B7DC4320282EDBDCC05254A
5E82616CB09CF4B9E5BB668AC4C77F021701550DDC63D296EAFA8C6969E18232
6C82B7FE6C915DC1194194741F38607571B9621B4709FBE775BE8A75A4DB9DAD
9F6ECF23EBB6370240F44034AFFA12D34F1C3CC496491A434A8D81135E33D40A
73C7C118113D3FA9BC07F4BCBC60BDA9C6ECC8AA9600A6F564EDFE34559A93DA
B791A6D55335C375BA74CA09740B64C03341107C98D2E7689B30BCE25D622EAF
2D6D01B51FF87F5558EB7E3BBFEFAB30321EFF92EE8CE732A034F2AF5B8B864A
2803C35F7DF8BFAF2792136EB12555A66087C1462183F1BE904FDF6C3892C56E
59700F309089F5ED75F50B1F195DE80432D0849F1105BB8B64C5667300134D31
6B38AB666A5DD9767A761E495DDCA78ABA2C102D3DFF5D7015EAAD53E4C6EBCB
D5EE0E236A738296B8DC783A3899CC07214532C07ACA5BFBF2431F7A2A5DA02B
27C455F8181A9EF62D9B54F911CC582B6BA58CDD428578C267901DEF8E591F1B
55DCC8A039E35E7A328D34E79177BD8FD1D8F2559E06CA8D34C81C387CF67A4F
30EAB6443435A3BC7944EFF7846E405BC90C83D509CFB727598A3D0A0B0FC53F
F11EEF6826E2F860C11AB5EE3F89AEEEFFE21D55FC1706561D0E0809131F4035
216EEE06B356A0CC6BD08C62B527844E5593F82DFF18F9CBDE4DB2B3337E62B6
96F75675DDACDEE68839A3D6572846F2F9B01523B51ED28CCFC10FA771E53572
BC2D4594E03F2E85C6F4D2D4012EA1C8E2DE061E4B7E5269A68DFAF665639134
1BC51835B2289111680377C08D341488187E52CC544C0C2FAD2C2076D872ABB3
D9700D44660DFB28BAA8F198B1250851F63B38DA9D6D7E9729769A94790ECAD1
093BBB1C24139239A744A3674365ABC9B15A71EDC80B680DAD90F30D986C2717
B5A732DA140300958C0E2289DA841894223F9B8DEA839D20B263EC344DF1C441
14FDAA0A031E3BF039A450DBEB7EBFFAEA588400552208A1AF68EF187DD810FF
8794572F820C78DDDFB39B32634D5B1DB45FE84FFBFDBFE327B5DBA5734C38B9
9883D6DC4F6DD1C280B0CB41BA325AB7306EDAFD4901F42A400D3712F2278612
8567DAF0BD5C5DB739EB6C73B93421D1F39BC43FCB4A075788AF69014770A080
838E9E93630F374F9E3236916FD5FFF628101E21C0222307D50C5B6E3283144F
EC5C08AC1C74E034CDC9EB6ACDDD26065E4B0BD0622EC3793044FC059610B256
B339B8D5310E740D306B10C5726DF46EEEA4CBBB7D6CD12CB21C28E3747807E1
5D288329731D7FDA3AB6D6EEC2E02A548B3EE19D539D0063222CBD2D78151D7B
272AE05825BF93A2E8E40674B347534D4C15162F56C2AAA6BC28E9F7980316D8
8899E4ECA85144FBF04BB49AD48DCD9A87E65B9A5EFD9910E0A230F83D4D0FDB
68E85FD1AFB3DAA3823072F7F06B9172581C11ECEF6B328CB9214661B585E8A9
62AEDB771300E2FBEAB9AEB51A80D8060D09B9815E21203CC67E86564A70AFA2
DBC8C8BA5F0ADB0531164B1FE56F9CDCCDC1757C7318E9F89C6A98ED5CE61107
AC82CE262F9D826D026332759B9A9608374EFF5D6E3ED55AC8B513D7F5AA0870
1AD362DA33E4EC9C5D10C039D2884D95C055DE165B9C0D6642939D5A53AD4CA1
88C70EA0396C5A0D58AFCE4549D80D3EE7B915B3E11B7B883B7F3D9EDB7E31A3
FF40C48D08300FBE1981232E2F2321E495C717833D5F303F61CBF53C8597F7B6
E3F1A79D64D31EB2077E503ACAB194DF172A843475AB8FBAC5D939DC84CD1361
58BD2B9FB01685B6150F988825800FCCAFFB3AF55BE0AC5364C8DAD013A6C125
A8D53F1E175033CD67206800C7822BE40D0D5E9EC57FCAE49A87975C90AE35B9
D3A681FB61ECEBEBDA148E1577674C9A82F06CC6CE2E6359F92B23AF9EE63155
2907A0A3DAB19A9F6583033C0B
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 6048082 8285720 1000 600 600 (aufkl_phototransistor.dvi)
@start /Fa 139[27 5[39 8[31 3[35 10[53 7[53 6[55 2[54
16[35 51[{ T1Encoding ReEncodeFont }9 66.4176 /SFRM0800
rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
% dvips-unknown
statusdict /setpageparams known { hsize vsize 0 1 statusdict begin {
setpageparams } stopped end } { true } ifelse { statusdict /setpage known
{ hsize vsize 1 statusdict begin { setpage } stopped pop end } if } if
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop 0 TeXcolorgray Black 0 TeXcolorgray
-600 -600 a
 /pssetRGBcolor /setrgbcolor load def /pssetCMYKcolor /setcmykcolor
load def /pssetGraycolor /setgray load def
 -600 -600 a -600 -600 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 -600 -600 a -600
-600 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 -600 -600 a
%%HiResBoundingBox: 0 0 92.28644pt 126.43008pt

%%PageBoundingBox: 0 0 92 126
%%HiResPageBoundingBox: 0 0 91.94142 125.95743
%%BeginPageSetup
<< /PageSize [91.94142 125.95743] >> setpagedevice
0 0 bop
%%EndPageSetup
 0 TeXcolorgray 0 TeXcolorgray -500
-75 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.85355 SLW 0.92 0.92 0.92  setrgbcolor   0.3 true 36.98865 31.29819
0.0 -11.38092 .5 Frame  gsave 0.98 0.98 0.98  setrgbcolor  1. .setopacityalpha
 fill  grestore gsave 0.85355 SLW 0.92 0.92 0.92  setrgbcolor  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial -500 -75
a
tx@Dict begin  { 4.26773 14.45387 } PutCoor PutBegin  end
 -500 -75 a Fa(Daten)-500 -75 y
tx@Dict begin  PutEnd  end
 -500 -75 a -500 -75
a
tx@Dict begin  { 4.26773 7.22693 } PutCoor PutBegin  end
 -500 -75 a Fa(GND)-500 -75 y
tx@Dict begin  PutEnd  end
 -500 -75 a -500 -75 a
tx@Dict begin  { 4.26773 0.0 } PutCoor PutBegin  end

-500 -75 a Fa(3)12 b(V)-500 -75 y
tx@Dict begin  PutEnd  end
 -500 -75 a 0 TeXcolorgray
0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
